import _extends from "@babel/runtime/helpers/esm/extends";
import _invoke from "lodash/invoke";
import { submenuBehavior, menuItemBehavior } from '@fluentui/accessibility';
import { compose, focusAsync, mergeVariablesOverrides, useTelemetry, useAutoControlled, useFluentContext, getElementType, useUnhandledProps, useAccessibility, useStyles } from '@fluentui/react-bindings';
import { EventListener } from '@fluentui/react-component-event-listener';
import { Ref, handleRef } from '@fluentui/react-component-ref';
import * as customPropTypes from '@fluentui/react-proptypes';
import * as PropTypes from 'prop-types';
import * as React from 'react';
import { childrenExist, createShorthand, doesNodeContainClick, commonPropTypes, isFromKeyboard as isEventFromKeyboard } from '../../utils';
import { Menu } from './Menu';
import { MenuItemIcon } from './MenuItemIcon';
import { MenuItemContent } from './MenuItemContent';
import { MenuItemIndicator } from './MenuItemIndicator';
import { MenuItemWrapper } from './MenuItemWrapper';
import { Popper, partitionPopperPropsFromShorthand } from '../../utils/positioner';
import { MenuContext } from './menuContext';
import { useContextSelectors } from '@fluentui/react-context-selector';
export var menuItemClassName = 'ui-menu__item';
export var menuItemSlotClassNames = {
  submenu: menuItemClassName + "__submenu"
};
/**
 * A MenuItem is an actionable item within a Menu.
 */

export var MenuItem = /*#__PURE__*/function () {
  var MenuItem = compose(function (inputProps, ref, composeOptions) {
    var context = useFluentContext();

    var _useTelemetry = useTelemetry(composeOptions.displayName, context.telemetry),
        setStart = _useTelemetry.setStart,
        setEnd = _useTelemetry.setEnd;

    setStart();
    var parentProps = useContextSelectors(MenuContext, {
      active: function active(v) {
        return v.activeIndex === inputProps.index;
      },
      onItemClick: function onItemClick(v) {
        return v.onItemClick;
      },
      variables: function variables(v) {
        return v.variables;
      },
      menuSlot: function menuSlot(v) {
        return v.slots.menu;
      },
      slotProps: function slotProps(v) {
        return v.slotProps.item;
      },
      accessibility: function accessibility(v) {
        return v.behaviors.item;
      }
    }); // TODO: we should improve typings for the useContextSelectors

    var props = Object.assign({}, parentProps.slotProps, {
      active: parentProps.active,
      variables: parentProps.variables,
      accessibility: parentProps.accessibility
    }, inputProps);
    var _props$accessibility = props.accessibility,
        accessibility = _props$accessibility === void 0 ? menuItemBehavior : _props$accessibility,
        children = props.children,
        content = props.content,
        icon = props.icon,
        wrapper = props.wrapper,
        primary = props.primary,
        secondary = props.secondary,
        active = props.active,
        vertical = props.vertical,
        indicator = props.indicator,
        disabled = props.disabled,
        underlined = props.underlined,
        iconOnly = props.iconOnly,
        inSubmenu = props.inSubmenu,
        pills = props.pills,
        pointing = props.pointing,
        className = props.className,
        design = props.design,
        styles = props.styles,
        variables = props.variables;

    var _partitionPopperProps = partitionPopperPropsFromShorthand(props.menu),
        menu = _partitionPopperProps[0],
        positioningProps = _partitionPopperProps[1];

    var _useAutoControlled = useAutoControlled({
      defaultValue: props.defaultMenuOpen,
      value: props.menuOpen,
      initialValue: false
    }),
        menuOpen = _useAutoControlled[0],
        setMenuOpen = _useAutoControlled[1];

    var _React$useState = React.useState(false),
        isFromKeyboard = _React$useState[0],
        setIsFromKeyboard = _React$useState[1];

    var ElementType = getElementType(props);
    var unhandledProps = useUnhandledProps(composeOptions.handledProps, props);
    var slotProps = composeOptions.resolveSlotProps(Object.assign({}, props, {
      accessibility: accessibility,
      variables: mergeVariablesOverrides(variables, parentProps.variables),
      isFromKeyboard: isFromKeyboard,
      menuOpen: menuOpen
    }));
    var getA11yProps = useAccessibility(accessibility, {
      debugName: composeOptions.displayName,
      actionHandlers: {
        performClick: function performClick(event) {
          return !event.defaultPrevented && handleClick(event);
        },
        openMenu: function (_openMenu) {
          function openMenu(_x) {
            return _openMenu.apply(this, arguments);
          }

          openMenu.toString = function () {
            return _openMenu.toString();
          };

          return openMenu;
        }(function (event) {
          return openMenu(event);
        }),
        closeAllMenusAndFocusNextParentItem: function closeAllMenusAndFocusNextParentItem(event) {
          return closeAllMenus(event);
        },
        closeMenu: function (_closeMenu) {
          function closeMenu(_x2) {
            return _closeMenu.apply(this, arguments);
          }

          closeMenu.toString = function () {
            return _closeMenu.toString();
          };

          return closeMenu;
        }(function (event) {
          return closeMenu(event);
        }),
        closeMenuAndFocusTrigger: function closeMenuAndFocusTrigger(event) {
          return closeMenu(event, true);
        },
        doNotNavigateNextParentItem: function doNotNavigateNextParentItem(event) {
          event.stopPropagation();
        },
        closeAllMenus: function (_closeAllMenus) {
          function closeAllMenus(_x3) {
            return _closeAllMenus.apply(this, arguments);
          }

          closeAllMenus.toString = function () {
            return _closeAllMenus.toString();
          };

          return closeAllMenus;
        }(function (event) {
          return closeAllMenus(event);
        })
      },
      mapPropsToBehavior: function mapPropsToBehavior() {
        return {
          menuOpen: menuOpen,
          hasMenu: !!menu,
          disabled: disabled,
          vertical: vertical,
          active: active // for tabBehavior

        };
      },
      rtl: context.rtl
    });

    var _useStyles = useStyles(MenuItem.displayName, {
      className: composeOptions.className,
      mapPropsToStyles: function mapPropsToStyles() {
        return {
          primary: primary,
          underlined: underlined,
          active: active,
          vertical: vertical,
          pointing: pointing,
          secondary: secondary,
          disabled: disabled,
          iconOnly: iconOnly,
          pills: pills,
          inSubmenu: inSubmenu,
          isFromKeyboard: isFromKeyboard
        };
      },
      mapPropsToInlineStyles: function mapPropsToInlineStyles() {
        return {
          className: className,
          design: design,
          styles: styles,
          variables: mergeVariablesOverrides(parentProps.variables, variables)
        };
      },
      rtl: context.rtl,
      composeOptions: composeOptions,
      unstable_props: Object.assign({}, props, {
        menuOpen: menuOpen,
        isFromKeyboard: isFromKeyboard
      })
    }),
        classes = _useStyles.classes,
        resolvedStyles = _useStyles.styles;

    var menuRef = React.useRef();
    var itemRef = React.useRef();

    var handleWrapperBlur = function handleWrapperBlur(e) {
      if (!props.inSubmenu && !e.currentTarget.contains(e.relatedTarget)) {
        trySetMenuOpen(false, e);
      }
    };

    var outsideClickHandler = function outsideClickHandler(e) {
      if (!isSubmenuOpen()) return;

      if (!doesNodeContainClick(itemRef.current, e, context.target) && !doesNodeContainClick(menuRef.current, e, context.target)) {
        trySetMenuOpen(false, e);
      }
    };

    var performClick = function performClick(e) {
      if (menu) {
        if (doesNodeContainClick(menuRef.current, e, context.target)) {
          // submenu was clicked => close it and propagate
          trySetMenuOpen(false, e, function () {
            return focusAsync(itemRef.current);
          });
        } else {
          // the menuItem element was clicked => toggle the open/close and stop propagation
          trySetMenuOpen(active ? !menuOpen : true, e);
          e.stopPropagation();
          e.preventDefault();
        }
      }
    };

    var handleClick = function handleClick(e) {
      if (disabled) {
        e.preventDefault();
        return;
      }

      performClick(e);

      _invoke(Object.assign({
        onClick: parentProps.onItemClick
      }, props), 'onClick', e, props);
    };

    var handleBlur = function handleBlur(e) {
      setIsFromKeyboard(false);

      _invoke(props, 'onBlur', e, props);
    };

    var handleFocus = function handleFocus(e) {
      setIsFromKeyboard(isEventFromKeyboard());

      _invoke(props, 'onFocus', e, props);
    };

    var isSubmenuOpen = function isSubmenuOpen() {
      return !!(menu && menuOpen);
    };

    var closeAllMenus = function closeAllMenus(e) {
      if (!isSubmenuOpen()) {
        return;
      }

      trySetMenuOpen(false, e, function () {
        if (!inSubmenu) {
          focusAsync(itemRef.current);
        }
      }); // avoid spacebar scrolling the page

      if (!inSubmenu) {
        e.preventDefault();
      }
    };

    var closeMenu = function closeMenu(e, forceTriggerFocus) {
      if (!isSubmenuOpen()) {
        return;
      }

      var shouldStopPropagation = inSubmenu || props.vertical;
      trySetMenuOpen(false, e, function () {
        if (forceTriggerFocus || shouldStopPropagation) {
          focusAsync(itemRef.current);
        }
      });

      if (forceTriggerFocus || shouldStopPropagation) {
        e.stopPropagation();
      }
    };

    var openMenu = function openMenu(e) {
      if (menu && !menuOpen) {
        trySetMenuOpen(true, e);

        _invoke(props, 'onActiveChanged', e, Object.assign({}, props, {
          active: true
        }));

        e.stopPropagation();
        e.preventDefault();
      }
    };

    var trySetMenuOpen = function trySetMenuOpen(newValue, e, onStateChanged) {
      setMenuOpen(newValue); // The reason why post-effect is not passed as callback to trySetState method
      // is that in 'controlled' mode the post-effect is applied before final re-rendering
      // which cause a broken behavior: for e.g. when it is needed to focus submenu trigger on ESC.
      // TODO: all DOM post-effects should be applied at componentDidMount & componentDidUpdated stages.

      onStateChanged && onStateChanged();

      _invoke(props, 'onMenuOpenChange', e, Object.assign({}, props, {
        menuOpen: newValue
      }));
    };

    var menuItemInner = /*#__PURE__*/React.createElement(Ref, {
      innerRef: function innerRef(node) {
        itemRef.current = node;
        handleRef(ref, node);
      }
    }, /*#__PURE__*/React.createElement(ElementType, _extends({}, getA11yProps('root', Object.assign({
      className: classes.root,
      disabled: disabled,
      onBlur: handleBlur,
      onFocus: handleFocus
    }, unhandledProps)), !wrapper && {
      onClick: handleClick
    }), childrenExist(children) ? children : /*#__PURE__*/React.createElement(React.Fragment, null, createShorthand(composeOptions.slots.icon, icon, {
      defaultProps: function defaultProps() {
        return getA11yProps('icon', slotProps.icon);
      }
    }), createShorthand(composeOptions.slots.content, content, {
      defaultProps: function defaultProps() {
        return getA11yProps('content', slotProps.content);
      }
    }), menu && createShorthand(composeOptions.slots.indicator, indicator, {
      defaultProps: function defaultProps() {
        return getA11yProps('indicator', slotProps.indicator);
      }
    }))));
    var maybeSubmenu = menu && active && menuOpen ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Ref, {
      innerRef: menuRef
    }, /*#__PURE__*/React.createElement(Popper, _extends({
      align: vertical ? 'top' : context.rtl ? 'end' : 'start',
      position: vertical ? context.rtl ? 'before' : 'after' : 'below',
      targetRef: itemRef
    }, positioningProps), createShorthand(parentProps.menuSlot || composeOptions.slots.menu || Menu, menu, {
      defaultProps: function defaultProps() {
        return Object.assign({}, slotProps.menu, {
          styles: resolvedStyles.menu
        });
      }
    }))), /*#__PURE__*/React.createElement(EventListener, {
      listener: outsideClickHandler,
      target: context.target,
      type: "click"
    })) : null;

    if (wrapper) {
      var wrapperElement = createShorthand(composeOptions.slots.wrapper, wrapper, {
        defaultProps: function defaultProps() {
          return getA11yProps('wrapper', slotProps.wrapper);
        },
        overrideProps: function overrideProps() {
          return {
            children: /*#__PURE__*/React.createElement(React.Fragment, null, menuItemInner, maybeSubmenu),
            onClick: handleClick,
            onBlur: handleWrapperBlur
          };
        }
      });
      setEnd();
      return wrapperElement;
    }

    setEnd();
    return menuItemInner;
  }, {
    displayName: 'MenuItem',
    className: menuItemClassName,
    slots: {
      icon: MenuItemIcon,
      indicator: MenuItemIndicator,
      content: MenuItemContent,
      wrapper: MenuItemWrapper
    },
    slotProps: function slotProps(props) {
      return {
        icon: {
          hasContent: !!props.content,
          iconOnly: props.iconOnly
        },
        content: {
          hasIcon: !!props.icon,
          hasMenu: !!props.menu,
          inSubmenu: props.inSubmenu,
          vertical: props.vertical
        },
        indicator: {
          iconOnly: props.iconOnly,
          vertical: props.vertical,
          inSubmenu: props.inSubmenu,
          active: props.active,
          primary: props.primary,
          underlined: props.underlined
        },
        wrapper: {
          active: props.active,
          disabled: props.disabled,
          iconOnly: props.iconOnly,
          isFromKeyboard: props.isFromKeyboard,
          pills: props.pills,
          pointing: props.pointing,
          secondary: props.secondary,
          underlined: props.underlined,
          vertical: props.vertical,
          primary: props.primary
        },
        menu: {
          accessibility: submenuBehavior,
          className: menuItemSlotClassNames.submenu,
          vertical: true,
          primary: props.primary,
          secondary: props.secondary,
          submenu: true,
          indicator: props.indicator
        }
      };
    },
    handledProps: ['accessibility', 'as', 'children', 'className', 'content', 'design', 'active', 'disabled', 'icon', 'iconOnly', 'index', 'itemPosition', 'itemsCount', 'onClick', 'onFocus', 'onBlur', 'pills', 'pointing', 'primary', 'secondary', 'underlined', 'vertical', 'wrapper', 'menu', 'menuOpen', 'defaultMenuOpen', 'onActiveChanged', 'inSubmenu', 'indicator', 'onMenuOpenChange', 'styles', 'variables'],
    shorthandConfig: {
      mappedProp: 'content'
    }
  });
  MenuItem.propTypes = Object.assign({}, commonPropTypes.createCommon({
    content: 'shorthand'
  }), {
    active: PropTypes.bool,
    disabled: PropTypes.bool,
    icon: customPropTypes.shorthandAllowingChildren,
    iconOnly: PropTypes.bool,
    index: PropTypes.number,
    itemPosition: PropTypes.number,
    itemsCount: PropTypes.number,
    onClick: PropTypes.func,
    onFocus: PropTypes.func,
    onBlur: PropTypes.func,
    pills: PropTypes.bool,
    pointing: PropTypes.oneOf(['start', 'end', true, false]),
    primary: customPropTypes.every([customPropTypes.disallow(['secondary']), PropTypes.bool]),
    secondary: customPropTypes.every([customPropTypes.disallow(['primary']), PropTypes.bool]),
    underlined: PropTypes.bool,
    vertical: PropTypes.bool,
    wrapper: PropTypes.oneOfType([PropTypes.node, PropTypes.object]),
    menu: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]),
    menuOpen: PropTypes.bool,
    defaultMenuOpen: PropTypes.bool,
    onActiveChanged: PropTypes.func,
    inSubmenu: PropTypes.bool,
    indicator: customPropTypes.shorthandAllowingChildren,
    onMenuOpenChange: PropTypes.func
  });
  MenuItem.defaultProps = {
    as: 'a',
    wrapper: {},
    indicator: {}
  };
  return MenuItem;
}();
//# sourceMappingURL=MenuItem.js.map
