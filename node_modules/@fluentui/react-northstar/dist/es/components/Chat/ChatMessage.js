import _extends from "@babel/runtime/helpers/esm/extends";
import _invoke from "lodash/invoke";
import { IS_FOCUSABLE_ATTRIBUTE, chatMessageBehavior, menuAsToolbarBehavior } from '@fluentui/accessibility';
import { getElementType, useUnhandledProps, useAccessibility, useFluentContext, useStyles, useTelemetry } from '@fluentui/react-bindings';
import { useContextSelector } from '@fluentui/react-context-selector';
import { Ref } from '@fluentui/react-component-ref';
import * as customPropTypes from '@fluentui/react-proptypes';
import cx from 'classnames';
import * as PropTypes from 'prop-types';
import * as React from 'react';
import { getScrollParent, Popper, partitionPopperPropsFromShorthand } from '../../utils/positioner';
import { childrenExist, createShorthandFactory, commonPropTypes, rtlTextContainer, createShorthand } from '../../utils';
import { Box } from '../Box/Box';
import { Label } from '../Label/Label';
import { Menu } from '../Menu/Menu';
import { Text } from '../Text/Text';
import { Reaction } from '../Reaction/Reaction';
import { ChatItemContext } from './chatItemContext';
import { ChatMessageHeader } from './ChatMessageHeader';
import { ChatMessageDetails } from './ChatMessageDetails';
export var chatMessageClassName = 'ui-chat__message';
export var chatMessageSlotClassNames = {
  actionMenu: chatMessageClassName + "__actions",
  author: chatMessageClassName + "__author",
  timestamp: chatMessageClassName + "__timestamp",
  badge: chatMessageClassName + "__badge",
  content: chatMessageClassName + "__content",
  reactionGroup: chatMessageClassName + "__reactions"
};
/**
 * A ChatMessage represents a single message in chat.
 */

export var ChatMessage = /*#__PURE__*/function () {
  var ChatMessage = function ChatMessage(props) {
    var context = useFluentContext();

    var _useTelemetry = useTelemetry(ChatMessage.displayName, context.telemetry),
        setStart = _useTelemetry.setStart,
        setEnd = _useTelemetry.setEnd;

    setStart();
    var parentAttached = useContextSelector(ChatItemContext, function (v) {
      return v.attached;
    });
    var accessibility = props.accessibility,
        _props$attached = props.attached,
        attached = _props$attached === void 0 ? parentAttached : _props$attached,
        author = props.author,
        badge = props.badge,
        badgePosition = props.badgePosition,
        children = props.children,
        className = props.className,
        content = props.content,
        design = props.design,
        mine = props.mine,
        positionActionMenu = props.positionActionMenu,
        reactionGroup = props.reactionGroup,
        reactionGroupPosition = props.reactionGroupPosition,
        timestamp = props.timestamp,
        styles = props.styles,
        variables = props.variables,
        header = props.header,
        details = props.details,
        overflow = props.unstable_overflow;

    var _partitionPopperProps = partitionPopperPropsFromShorthand(props.actionMenu),
        actionMenu = _partitionPopperProps[0],
        positioningProps = _partitionPopperProps[1];

    var _React$useState = React.useState(false),
        focused = _React$useState[0],
        setFocused = _React$useState[1];

    var _React$useState2 = React.useState(null),
        messageNode = _React$useState2[0],
        setMessageNode = _React$useState2[1];

    var updateActionsMenuPosition = React.useRef(null);
    var getA11Props = useAccessibility(accessibility, {
      actionHandlers: {
        // prevents default FocusZone behavior, e.g., in ChatMessageBehavior, it prevents FocusZone from using arrow keys
        // as navigation (only Tab key should work)
        preventDefault: function preventDefault(event) {
          // preventDefault only if event coming from inside the message
          if (event.currentTarget !== event.target) {
            event.preventDefault();
          }
        },
        focus: function focus(event) {
          if (messageNode) {
            messageNode.focus();
            event.stopPropagation();
          }
        }
      }
    });

    var _useStyles = useStyles(ChatMessage.displayName, {
      className: chatMessageClassName,
      mapPropsToStyles: function mapPropsToStyles() {
        return {
          attached: attached,
          badgePosition: badgePosition,
          focused: focused,
          mine: mine,
          hasBadge: !!badge,
          hasReactionGroup: !!reactionGroup
        };
      },
      mapPropsToInlineStyles: function mapPropsToInlineStyles() {
        return {
          className: className,
          design: design,
          styles: styles,
          variables: variables
        };
      },
      rtl: context.rtl
    }),
        classes = _useStyles.classes,
        resolvedStyles = _useStyles.styles;

    var handleFocus = function handleFocus(e) {
      _invoke(updateActionsMenuPosition, 'current');

      setFocused(true);

      _invoke(props, 'onFocus', e, props);
    };

    var handleBlur = function handleBlur(e) {
      // `focused` controls is focused the whole `ChatMessage` or any of its children. When we're navigating
      // with keyboard the focused element will be changed and there is no way to use `:focus` selector
      var shouldPreserveFocusState = _invoke(e, 'currentTarget.contains', e.relatedTarget);

      setFocused(shouldPreserveFocusState);

      _invoke(props, 'onBlur', e, props);
    };

    var handleMouseEnter = function handleMouseEnter(e) {
      _invoke(updateActionsMenuPosition, 'current');

      _invoke(props, 'onMouseEnter', e, props);
    };

    var renderActionMenu = function renderActionMenu() {
      var actionMenuElement = Menu.create(actionMenu, {
        defaultProps: function defaultProps() {
          var _ref;

          return _ref = {}, _ref[IS_FOCUSABLE_ATTRIBUTE] = true, _ref.accessibility = menuAsToolbarBehavior, _ref.className = chatMessageSlotClassNames.actionMenu, _ref.styles = resolvedStyles.actionMenu, _ref;
        }
      });

      if (!actionMenuElement) {
        return actionMenuElement;
      }

      var modifiers = positionActionMenu && [// https://popper.js.org/docs/v2/modifiers/flip/
      // Forces to flip only in "top-*" positions
      {
        name: 'flip',
        options: {
          fallbackPlacements: ['top']
        }
      }, overflow && {
        name: 'preventOverflow',
        options: {
          boundary: getScrollParent(messageNode)
        }
      }];
      return /*#__PURE__*/React.createElement(Popper, _extends({
        enabled: positionActionMenu,
        align: "end",
        modifiers: modifiers,
        position: "above",
        positionFixed: overflow,
        targetRef: messageNode
      }, positioningProps), function (_ref2) {
        var scheduleUpdate = _ref2.scheduleUpdate;
        updateActionsMenuPosition.current = scheduleUpdate;
        return actionMenuElement;
      });
    };

    var childrenPropExists = childrenExist(children);
    var rootClasses = childrenPropExists ? cx(classes.root, classes.content) : classes.root;
    var ElementType = getElementType(props);
    var unhandledProps = useUnhandledProps(ChatMessage.handledProps, props);
    var badgeElement = Label.create(badge, {
      defaultProps: function defaultProps() {
        return {
          className: chatMessageSlotClassNames.badge,
          styles: resolvedStyles.badge
        };
      }
    });
    var reactionGroupElement = Reaction.Group.create(reactionGroup, {
      defaultProps: function defaultProps() {
        return {
          className: chatMessageSlotClassNames.reactionGroup,
          styles: resolvedStyles.reactionGroup
        };
      }
    });
    var actionMenuElement = renderActionMenu();
    var authorElement = Text.create(author, {
      defaultProps: function defaultProps() {
        return {
          size: 'small',
          styles: resolvedStyles.author,
          className: chatMessageSlotClassNames.author
        };
      }
    });
    var timestampElement = Text.create(timestamp, {
      defaultProps: function defaultProps() {
        return {
          size: 'small',
          styles: resolvedStyles.timestamp,
          timestamp: true,
          className: chatMessageSlotClassNames.timestamp
        };
      }
    });
    var messageContent = Box.create(content, {
      defaultProps: function defaultProps() {
        return {
          className: chatMessageSlotClassNames.content,
          styles: resolvedStyles.content
        };
      }
    });
    var detailsElement = createShorthand(ChatMessageDetails, details, {
      defaultProps: function defaultProps() {
        return {
          mine: mine
        };
      }
    });
    var headerElement = createShorthand(ChatMessageHeader, header || {}, {
      overrideProps: function overrideProps() {
        return {
          content: /*#__PURE__*/React.createElement(React.Fragment, null, authorElement, timestampElement, detailsElement, reactionGroupPosition === 'start' && reactionGroupElement)
        };
      }
    });
    var element = /*#__PURE__*/React.createElement(Ref, {
      innerRef: setMessageNode
    }, getA11Props.unstable_wrapWithFocusZone( /*#__PURE__*/React.createElement(ElementType, getA11Props('root', Object.assign({
      className: rootClasses,
      onBlur: handleBlur,
      onFocus: handleFocus,
      onMouseEnter: handleMouseEnter
    }, rtlTextContainer.getAttributes({
      forElements: [children]
    }), unhandledProps)), childrenPropExists ? children : /*#__PURE__*/React.createElement(React.Fragment, null, actionMenuElement, badgePosition === 'start' && badgeElement, headerElement, messageContent, reactionGroupPosition === 'end' && reactionGroupElement, badgePosition === 'end' && badgeElement))));
    setEnd();
    return element;
  };

  ChatMessage.displayName = 'ChatMessage';
  ChatMessage.defaultProps = {
    accessibility: chatMessageBehavior,
    badgePosition: 'end',
    positionActionMenu: true,
    reactionGroupPosition: 'start'
  };
  ChatMessage.propTypes = Object.assign({}, commonPropTypes.createCommon({
    content: 'shorthand'
  }), {
    actionMenu: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]),
    attached: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['top', 'bottom'])]),
    author: customPropTypes.itemShorthand,
    badge: customPropTypes.itemShorthand,
    details: customPropTypes.itemShorthand,
    badgePosition: PropTypes.oneOf(['start', 'end']),
    header: customPropTypes.itemShorthand,
    mine: PropTypes.bool,
    timestamp: customPropTypes.itemShorthand,
    onBlur: PropTypes.func,
    onFocus: PropTypes.func,
    onMouseEnter: PropTypes.func,
    positionActionMenu: PropTypes.bool,
    reactionGroup: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]),
    reactionGroupPosition: PropTypes.oneOf(['start', 'end']),
    unstable_overflow: PropTypes.bool
  });
  ChatMessage.handledProps = Object.keys(ChatMessage.propTypes);
  ChatMessage.create = createShorthandFactory({
    Component: ChatMessage,
    mappedProp: 'content'
  });
  return ChatMessage;
}();
//# sourceMappingURL=ChatMessage.js.map
