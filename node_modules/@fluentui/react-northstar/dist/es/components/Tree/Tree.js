import _invoke from "lodash/invoke";
import _reduce from "lodash/reduce";
import { treeBehavior } from '@fluentui/accessibility';
import { getNextElement, useAutoControlled, useTelemetry, useUnhandledProps, getElementType, useAccessibility, useStyles, useFluentContext } from '@fluentui/react-bindings';
import * as customPropTypes from '@fluentui/react-proptypes';
import * as PropTypes from 'prop-types';
import * as React from 'react';
import { Ref } from '@fluentui/react-component-ref';
import { TreeItem } from './TreeItem';
import { TreeTitle } from './TreeTitle';
import { childrenExist, commonPropTypes, createShorthandFactory, rtlTextContainer } from '../../utils';
import { getAllSelectableChildrenId, isAllGroupChecked, hasSubtree, removeItemAtIndex, getSiblings, TreeContext, processItemsForSelection } from './utils';
export var treeClassName = 'ui-tree';

function useStableProps(props) {
  var stableProps = React.useRef(props);
  React.useEffect(function () {
    stableProps.current = props;
  });
  return stableProps;
}

var expandedItemsGenerator = function expandedItemsGenerator(items, acc) {
  if (acc === void 0) {
    acc = [];
  }

  return _reduce(items, function (acc, item) {
    if (item['expanded'] && acc.indexOf(item['id']) === -1) {
      acc.push(item['id']);
    }

    if (item['items']) {
      return expandedItemsGenerator(item['items'], acc);
    }

    return acc;
  }, acc);
};

var iterateItems = function iterateItems(items, acc) {
  if (acc === void 0) {
    acc = [];
  }

  return _reduce(items, function (acc, item) {
    if (item['selected'] && acc.indexOf(item['id']) === -1) {
      acc.push(item['id']);
    }

    if (item['items']) {
      return iterateItems(item['items']);
    }

    return acc;
  }, acc);
};
/**
 * A Tree displays data organised in tree hierarchy.
 *
 * @accessibility
 * Implements [ARIA TreeView](https://www.w3.org/TR/wai-aria-practices-1.1/#TreeView) design pattern.
 * @accessibilityIssues
 * [Treeview - JAWS doesn't narrate position for each tree item](https://github.com/FreedomScientific/VFO-standards-support/issues/338)
 * [Aria compliant trees are read as empty tables](https://bugs.chromium.org/p/chromium/issues/detail?id=1048770)
 */


export var Tree = /*#__PURE__*/function () {
  var Tree = function Tree(props) {
    var context = useFluentContext();

    var _useTelemetry = useTelemetry(Tree.displayName, context.telemetry),
        setStart = _useTelemetry.setStart,
        setEnd = _useTelemetry.setEnd;

    setStart();
    var exclusive = props.exclusive,
        items = props.items,
        renderItemTitle = props.renderItemTitle,
        selectable = props.selectable,
        children = props.children,
        renderedItems = props.renderedItems,
        className = props.className,
        design = props.design,
        styles = props.styles,
        variables = props.variables;
    var stableProps = useStableProps(props);
    var ElementType = getElementType(props);
    var unhandledProps = useUnhandledProps(Tree.handledProps, props);

    var _useAutoControlled = useAutoControlled({
      defaultValue: props.defaultActiveItemIds,
      value: props.activeItemIds,
      initialValue: expandedItemsGenerator(items)
    }),
        activeItemIds = _useAutoControlled[0],
        setActiveItemIdsState = _useAutoControlled[1];

    var _useAutoControlled2 = useAutoControlled({
      defaultValue: props.defaultSelectedItemIds,
      value: props.selectedItemIds,
      initialValue: iterateItems(items)
    }),
        selectedItemIds = _useAutoControlled2[0],
        setSelectedItemIdsState = _useAutoControlled2[1];

    var getA11yProps = useAccessibility(props.accessibility, {
      debugName: Tree.displayName,
      rtl: context.rtl
    });

    var _useStyles = useStyles(Tree.displayName, {
      className: treeClassName,
      mapPropsToInlineStyles: function mapPropsToInlineStyles() {
        return {
          className: className,
          design: design,
          styles: styles,
          variables: variables
        };
      },
      rtl: context.rtl
    }),
        classes = _useStyles.classes;

    var treeRef = React.useRef();
    var itemsRef = React.useRef(new Map());
    var onFocusParent = React.useCallback(function (parent) {
      var parentRef = itemsRef.current.get(parent);

      if (!parentRef || !parentRef.current) {
        return;
      }

      parentRef.current.focus();
    }, [itemsRef]);
    var setSelectedItemIds = React.useCallback(function (e, updateSelectedItemIds) {
      _invoke(stableProps.current, 'onSelectedItemIdsChange', e, Object.assign({}, stableProps.current, {
        selectedItemIds: updateSelectedItemIds
      }));

      setSelectedItemIdsState(updateSelectedItemIds);
    }, [stableProps, setSelectedItemIdsState]);
    var setActiveItemIds = React.useCallback(function (e, updateActiveItemIds) {
      _invoke(stableProps.current, 'onActiveItemIdsChange', e, Object.assign({}, stableProps.current, {
        activeItemIds: updateActiveItemIds
      }));

      setActiveItemIdsState(updateActiveItemIds);
    }, [stableProps, setActiveItemIdsState]);
    var expandItems = React.useCallback(function (e, treeItemProps) {
      var id = treeItemProps.id;
      setActiveItemIds(e, function (currActiveItemIds) {
        var siblings = getSiblings(stableProps.current.items, id);
        var activeItemIdIndex = currActiveItemIds.indexOf(id);
        var nextActiveItemsIds = currActiveItemIds;

        if (activeItemIdIndex > -1) {
          nextActiveItemsIds = removeItemAtIndex(currActiveItemIds, activeItemIdIndex);
        } else {
          if (exclusive) {
            siblings.some(function (sibling) {
              var activeSiblingIdIndex = currActiveItemIds.indexOf(sibling['id']);

              if (activeSiblingIdIndex > -1) {
                nextActiveItemsIds = removeItemAtIndex(currActiveItemIds, activeSiblingIdIndex);
                return true;
              }

              return false;
            });
          }

          nextActiveItemsIds = [].concat(nextActiveItemsIds, [id]);
        }

        return nextActiveItemsIds;
      });
    }, [stableProps, setActiveItemIds, exclusive]);
    var onTitleClick = React.useCallback(function (e, treeItemProps, executeSelection) {
      if (executeSelection === void 0) {
        executeSelection = false;
      }

      var treeItemHasSubtree = hasSubtree(treeItemProps);

      if (!treeItemProps) {
        return;
      }

      if (treeItemHasSubtree && !executeSelection) {
        expandItems(e, treeItemProps);
      }

      if (treeItemProps.selectable) {
        // parent must be selectable and expanded in order to procced with selection, otherwise return
        if (treeItemHasSubtree && !(treeItemProps.selectableParent && treeItemProps.expanded)) {
          return;
        }

        if (treeItemHasSubtree && !executeSelection) {
          return;
        }

        setSelectedItemIds(e, function (currSelectedItemIds) {
          return processItemsForSelection(treeItemProps, currSelectedItemIds);
        });
      }
    }, [expandItems, setSelectedItemIds]);
    var onFocusFirstChild = React.useCallback(function (itemId) {
      var currentElement = itemsRef.current.get(itemId);

      if (!currentElement || !currentElement.current) {
        return;
      }

      var elementToBeFocused = getNextElement(treeRef.current, currentElement.current);

      if (!elementToBeFocused) {
        return;
      }

      elementToBeFocused.focus();
    }, [treeRef, itemsRef]);
    var isActiveItem = React.useCallback(function (id) {
      return activeItemIds.indexOf(id) > -1;
    }, [activeItemIds]);
    var onSiblingsExpand = React.useCallback(function (e, treeItemProps) {
      if (exclusive) {
        return;
      }

      var id = treeItemProps.id;
      var siblings = getSiblings(stableProps.current.items, id);
      setActiveItemIds(e, function (currActiveItemIds) {
        var nextActiveItemsIds = [].concat(currActiveItemIds);
        siblings.forEach(function (sibling) {
          if (hasSubtree(sibling) && !isActiveItem(sibling['id'])) {
            nextActiveItemsIds.push(sibling['id']);
          }
        });

        if (hasSubtree(treeItemProps) && !isActiveItem(id)) {
          nextActiveItemsIds.push(id);
        }

        return nextActiveItemsIds;
      });
    }, [exclusive, stableProps, isActiveItem, setActiveItemIds]);

    var isIndeterminate = function isIndeterminate(item) {
      if (!item.selectableParent || !item.items) {
        return false;
      }

      var selectableItemIds = getAllSelectableChildrenId(item.items);
      return !isAllGroupChecked(item.items, selectedItemIds) && selectableItemIds.some(function (id) {
        return selectedItemIds.indexOf(id) > -1;
      });
    };

    var isSelectedItem = function isSelectedItem(item) {
      if (item.selectableParent && item.items) {
        return isAllGroupChecked(item.items, selectedItemIds);
      }

      return selectedItemIds && selectedItemIds.indexOf(item.id) > -1;
    };

    var contextValue = React.useMemo(function () {
      return {
        onFocusParent: onFocusParent,
        onSiblingsExpand: onSiblingsExpand,
        onFocusFirstChild: onFocusFirstChild,
        onTitleClick: onTitleClick
      };
    }, [onFocusParent, onSiblingsExpand, onFocusFirstChild, onTitleClick]);

    var renderContent = function renderContent() {
      if (!items) return null;

      var renderItems = function renderItems(items, level, parent) {
        if (level === void 0) {
          level = 1;
        }

        return items.reduce(function (renderedItems, item, index) {
          var id = item.id;
          var isSubtree = hasSubtree(item);
          var isSubtreeExpanded = isSubtree && isActiveItem(id);
          var indeterminate = isIndeterminate(item);

          if (!itemsRef.current.has(id)) {
            itemsRef.current.set(id, /*#__PURE__*/React.createRef());
          }

          var renderedItem = TreeItem.create(item, {
            defaultProps: function defaultProps() {
              return getA11yProps('item', {
                expanded: isSubtreeExpanded,
                selected: isSelectedItem(item),
                selectable: selectable,
                renderItemTitle: renderItemTitle,
                id: id,
                key: id,
                parent: parent,
                level: level,
                index: index + 1,
                // Used for aria-posinset and it's 1-based.
                contentRef: itemsRef.current.get(id),
                treeSize: items.length,
                indeterminate: indeterminate,
                onSiblingsExpand: onSiblingsExpand
              });
            }
          });
          return [].concat(renderedItems, [renderedItem], isSubtreeExpanded ? renderItems(item.items, level + 1, id) : []);
        }, []);
      };

      var itemsRendered = renderItems(items);
      return itemsRendered;
    };

    var element = /*#__PURE__*/React.createElement(TreeContext.Provider, {
      value: contextValue
    }, /*#__PURE__*/React.createElement(Ref, {
      innerRef: treeRef
    }, getA11yProps.unstable_wrapWithFocusZone( /*#__PURE__*/React.createElement(ElementType, getA11yProps('root', Object.assign({
      className: classes.root
    }, rtlTextContainer.getAttributes({
      forElements: [children]
    }), unhandledProps)), childrenExist(children) ? children : renderedItems ? renderedItems(renderContent()) : renderContent()))));
    setEnd();
    return element;
  };

  Tree.displayName = 'Tree';
  Tree.propTypes = Object.assign({}, commonPropTypes.createCommon({
    content: false
  }), {
    activeItemIds: customPropTypes.collectionShorthand,
    selectedItemIds: customPropTypes.collectionShorthand,
    defaultActiveItemIds: customPropTypes.collectionShorthand,
    defaultSelectedItemIds: customPropTypes.collectionShorthand,
    exclusive: PropTypes.bool,
    selectable: PropTypes.bool,
    items: customPropTypes.collectionObjectShorthand,
    onActiveItemIdsChange: PropTypes.func,
    onSelectedItemIdsChange: PropTypes.func,
    renderItemTitle: PropTypes.func,
    renderedItems: PropTypes.func
  });
  Tree.Item = TreeItem;
  Tree.Title = TreeTitle;
  Tree.defaultProps = {
    accessibility: treeBehavior
  };
  Tree.handledProps = Object.keys(Tree.propTypes);
  Tree.create = createShorthandFactory({
    Component: Tree,
    mappedArrayProp: 'items'
  });
  return Tree;
}();
//# sourceMappingURL=Tree.js.map
