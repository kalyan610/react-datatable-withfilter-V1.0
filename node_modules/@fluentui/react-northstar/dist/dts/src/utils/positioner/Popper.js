"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var PopperJs = require("@popperjs/core");
var _ = require("lodash");
var React = require("react");
var isBrowser_1 = require("../isBrowser");
var getBoundary_1 = require("./getBoundary");
var getScrollParent_1 = require("./getScrollParent");
var positioningHelper_1 = require("./positioningHelper");
var reactInstanceKey;
var getReactInstanceKey = function (elm) {
    if (!reactInstanceKey) {
        for (var k in elm) {
            if (k.indexOf('__reactInternalInstance$') === 0) {
                reactInstanceKey = k;
                break;
            }
        }
    }
    return reactInstanceKey;
};
var hasAutofocusProp = function (node) {
    // https://github.com/facebook/react/blob/848bb2426e44606e0a55dfe44c7b3ece33772485/packages/react-dom/src/client/ReactDOMHostConfig.js#L157-L166
    return ((node.nodeName === 'BUTTON' ||
        node.nodeName === 'INPUT' ||
        node.nodeName === 'SELECT' ||
        node.nodeName === 'TEXTAREA') &&
        node[getReactInstanceKey(node)].pendingProps.autoFocus);
};
function hasAutofocusFilter(node) {
    return hasAutofocusProp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
}
// We are setting the position to `fixed` in the first effect
// To prevent scroll jumps in case of the content with managed focus
// Modifier sets the position to `fixed` before all other modifier effects
// Patch updates `forceUpdate` Popper function
// which restores the original position before the first forceUpdate call
var usePopperInitialPositionFix = function (contentRef) {
    var originalStateRef = React.useRef('absolute');
    if (process.env.NODE_ENV !== 'production') {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        React.useEffect(function () {
            var _a;
            if (contentRef.current) {
                var contentNode = contentRef.current;
                var treeWalker = (_a = contentNode.ownerDocument) === null || _a === void 0 ? void 0 : _a.createTreeWalker(contentNode, NodeFilter.SHOW_ELEMENT, {
                    acceptNode: hasAutofocusFilter,
                });
                while (treeWalker.nextNode()) {
                    var node = treeWalker.currentNode;
                    // eslint-disable-next-line no-console
                    console.warn('<Popper>:', node);
                    // eslint-disable-next-line no-console
                    console.warn([
                        '<Popper>: ^ this node contains "autoFocus" prop on a React element. This can break the initial',
                        'positioning of an element and cause a window jump effect. This issue occurs because React polyfills',
                        '"autoFocus" behavior to solve inconsistencies between different browsers:',
                        'https://github.com/facebook/react/issues/11851#issuecomment-351787078',
                        '\n',
                        'However, ".focus()" in this case occurs before any other React effects will be executed',
                        '(React.useEffect(), componentDidMount(), etc.) and we can not prevent this behavior. If you really',
                        'want to use "autoFocus" please add "position: fixed" to styles of the element that is wrapped by',
                        '"Popper".',
                        "In general, it's not recommended to use \"autoFocus\" as it may break accessibility aspects:",
                        'https://github.com/jsx-eslint/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-autofocus.md',
                        '\n',
                        'We suggest to use the "trapFocus" prop on Fluent components or a catch "ref" and then use',
                        '"ref.current.focus" in React.useEffect():',
                        'https://reactjs.org/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element',
                    ].join(' '));
                }
            }
            // We run this check once, no need to add deps here
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, []);
    }
    return React.useMemo(function () { return ({
        patch: function (popperInstance) {
            var originalForceUpdate = popperInstance.forceUpdate;
            popperInstance.isFirstRun = true;
            popperInstance.forceUpdate = function () {
                if (popperInstance.isFirstRun) {
                    popperInstance.state.elements.popper.style['position'] = originalStateRef.current;
                    popperInstance.isFirstRun = false;
                }
                originalForceUpdate();
            };
        },
        modifier: {
            name: 'positionStyleFix',
            enabled: true,
            phase: 'afterWrite',
            effect: function (_a) {
                var state = _a.state;
                originalStateRef.current = state.elements.popper.style['position'];
                state.elements.popper.style['position'] = 'fixed';
                return function () { };
            },
            requires: [],
        },
    }); }, []);
};
/**
 * Memoize a result using deep equality. This hook has two advantages over
 * React.useMemo: it uses deep equality to compare memo keys, and it guarantees
 * that the memo function will only be called if the keys are unequal.
 * React.useMemo cannot be relied on to do this, since it is only a performance
 * optimization (see https://reactjs.org/docs/hooks-reference.html#usememo).
 *
 * Copied from https://github.com/apollographql/react-apollo/blob/master/packages/hooks/src/utils/useDeepMemo.ts.
 */
function useDeepMemo(memoFn, key) {
    var ref = React.useRef();
    if (!ref.current || !_.isEqual(key, ref.current.key)) {
        ref.current = { key: key, value: memoFn() };
    }
    return ref.current.value;
}
/** Checks if components was mounted the first time. */
function useFirstMount() {
    var isFirst = React.useRef(true);
    if (isFirst.current) {
        isFirst.current = false;
        return true;
    }
    return isFirst.current;
}
/** Executes useIsomorphicLayoutEffect during only updates. */
var useUpdateIsomorphicLayoutEffect = function (effect, deps) {
    var isFirstMount = useFirstMount();
    react_bindings_1.useIsomorphicLayoutEffect(function () {
        if (!isFirstMount) {
            return effect();
        }
    }, deps);
};
/**
 * Popper relies on the 3rd party library [Popper.js](https://github.com/FezVrasta/popper.js) for positioning.
 */
exports.Popper = function (props) {
    var align = props.align, children = props.children, enabled = props.enabled, flipBoundary = props.flipBoundary, userModifiers = props.modifiers, offset = props.offset, overflowBoundary = props.overflowBoundary, pointerTargetRef = props.pointerTargetRef, popperRef = props.popperRef, position = props.position, positionFixed = props.positionFixed, _a = props.positioningDependencies, positioningDependencies = _a === void 0 ? [] : _a, rtl = props.rtl, targetRef = props.targetRef, unstable_disableTether = props.unstable_disableTether, unstable_pinned = props.unstable_pinned;
    var proposedPlacement = positioningHelper_1.getPlacement({ align: align, position: position, rtl: rtl });
    var popperInstanceRef = React.useRef();
    var contentRef = React.useRef(null);
    var popperInitialPositionFix = usePopperInitialPositionFix(contentRef);
    var latestPlacement = React.useRef(proposedPlacement);
    var _b = React.useState(proposedPlacement), computedPlacement = _b[0], setComputedPlacement = _b[1];
    var computedModifiers = useDeepMemo(function () { return tslib_1.__spreadArrays([
        offset && {
            name: 'offset',
            options: { offset: rtl ? positioningHelper_1.applyRtlToOffset(offset) : offset },
        }
    ], userModifiers); }, [offset, flipBoundary, overflowBoundary, userModifiers]);
    var createInstance = React.useCallback(function () {
        var reference = targetRef && react_component_ref_1.isRefObject(targetRef)
            ? targetRef.current
            : targetRef;
        if (!enabled || !reference || !contentRef.current) {
            return;
        }
        var handleUpdate = function (_a) {
            var state = _a.state;
            // PopperJS performs computations that might update the computed placement: auto positioning, flipping the
            // placement in case the popper box should be rendered at the edge of the viewport and does not fit
            if (state.placement !== latestPlacement.current) {
                latestPlacement.current = state.placement;
                setComputedPlacement(state.placement);
            }
        };
        var hasDocument = isBrowser_1.isBrowser();
        var scrollParentElement = hasDocument ? getScrollParent_1.getScrollParent(contentRef.current) : null;
        var hasScrollableElement = scrollParentElement
            ? scrollParentElement !== scrollParentElement.ownerDocument.body
            : false;
        var hasPointer = !!(pointerTargetRef && pointerTargetRef.current);
        var modifiers = [
            { name: 'flip', options: { flipVariations: true } },
            /**
             * unstable_pinned disables the flip modifier by setting flip.enabled to false; this
             * disables automatic repositioning of the popper box; it will always be placed according to
             * the values of `align` and `position` props, regardless of the size of the component, the
             * reference element or the viewport.
             */
            unstable_pinned && { name: 'flip', enabled: false },
            /**
             * When the popper box is placed in the context of a scrollable element, we need to set
             * preventOverflow.escapeWithReference to true and flip.boundariesElement to 'scrollParent'
             * (default is 'viewport') so that the popper box will stick with the targetRef when we
             * scroll targetRef out of the viewport.
             */
            hasScrollableElement && { name: 'flip', options: { boundary: 'clippingParents' } },
            hasScrollableElement && { name: 'preventOverflow', options: { boundary: 'clippingParents' } },
        ];
        var options = {
            placement: proposedPlacement,
            strategy: positionFixed ? 'fixed' : 'absolute',
            modifiers: tslib_1.__spreadArrays(modifiers, computedModifiers, [
                /**
                 * This modifier is necessary in order to render the pointer. Refs are resolved in effects, so it can't be
                 * placed under computed modifiers. Deep merge is not required as this modifier has only these properties.
                 */
                {
                    name: 'arrow',
                    enabled: hasPointer,
                    options: {
                        element: pointerTargetRef && pointerTargetRef.current,
                    },
                },
                /**
                 * This modifier is necessary to retain behaviour from popper v1 where untethered poppers are allowed by
                 * default. i.e. popper is still rendered fully in the viewport even if anchor element is no longer in the
                 * viewport.
                 */
                unstable_disableTether && {
                    name: 'preventOverflow',
                    options: { altAxis: unstable_disableTether === 'all', tether: false },
                },
                flipBoundary && {
                    name: 'flip',
                    options: {
                        altBoundary: true,
                        boundary: getBoundary_1.getBoundary(contentRef.current, flipBoundary),
                    },
                },
                overflowBoundary && {
                    name: 'preventOverflow',
                    options: {
                        altBoundary: true,
                        boundary: getBoundary_1.getBoundary(contentRef.current, overflowBoundary),
                    },
                },
                {
                    name: 'onUpdate',
                    enabled: true,
                    phase: 'afterWrite',
                    fn: handleUpdate,
                },
                popperInitialPositionFix.modifier,
            ]).filter(Boolean),
            onFirstUpdate: function (state) { return handleUpdate({ state: state }); },
        };
        popperInstanceRef.current = PopperJs.createPopper(reference, contentRef.current, options);
        popperInitialPositionFix.patch(popperInstanceRef.current);
    }, [
        contentRef,
        computedModifiers,
        enabled,
        flipBoundary,
        overflowBoundary,
        pointerTargetRef,
        positionFixed,
        proposedPlacement,
        targetRef,
        unstable_disableTether,
        unstable_pinned,
        popperInitialPositionFix,
    ]);
    var destroyInstance = React.useCallback(function () {
        if (popperInstanceRef.current) {
            popperInstanceRef.current.destroy();
            popperInstanceRef.current = null;
        }
    }, []);
    var scheduleUpdate = React.useCallback(function () {
        if (popperInstanceRef.current) {
            popperInstanceRef.current.update();
        }
    }, []);
    React.useImperativeHandle(popperRef, function () { return ({
        updatePosition: scheduleUpdate,
    }); }, [scheduleUpdate]);
    react_bindings_1.useIsomorphicLayoutEffect(function () {
        createInstance();
        return destroyInstance;
    }, [createInstance]);
    useUpdateIsomorphicLayoutEffect(scheduleUpdate, tslib_1.__spreadArrays(positioningDependencies, [computedPlacement]));
    var child = typeof children === 'function'
        ? children({ placement: computedPlacement, scheduleUpdate: scheduleUpdate })
        : children;
    return child ? React.createElement(react_component_ref_1.Ref, { innerRef: contentRef }, React.Children.only(child)) : null;
};
exports.Popper.defaultProps = {
    enabled: true,
    modifiers: [],
    positionFixed: false,
    positioningDependencies: [],
};
