"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_event_listener_1 = require("@fluentui/react-component-event-listener");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var utils_1 = require("../../utils");
var Menu_1 = require("./Menu");
var MenuItemIcon_1 = require("./MenuItemIcon");
var MenuItemContent_1 = require("./MenuItemContent");
var MenuItemIndicator_1 = require("./MenuItemIndicator");
var MenuItemWrapper_1 = require("./MenuItemWrapper");
var positioner_1 = require("../../utils/positioner");
var menuContext_1 = require("./menuContext");
var react_context_selector_1 = require("@fluentui/react-context-selector");
exports.menuItemClassName = 'ui-menu__item';
exports.menuItemSlotClassNames = {
    submenu: exports.menuItemClassName + "__submenu",
};
/**
 * A MenuItem is an actionable item within a Menu.
 */
exports.MenuItem = react_bindings_1.compose(function (inputProps, ref, composeOptions) {
    var context = react_bindings_1.useFluentContext();
    var _a = react_bindings_1.useTelemetry(composeOptions.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var parentProps = react_context_selector_1.useContextSelectors(menuContext_1.MenuContext, {
        active: function (v) { return v.activeIndex === inputProps.index; },
        onItemClick: function (v) { return v.onItemClick; },
        variables: function (v) { return v.variables; },
        menuSlot: function (v) { return v.slots.menu; },
        slotProps: function (v) { return v.slotProps.item; },
        accessibility: function (v) { return v.behaviors.item; },
    }); // TODO: we should improve typings for the useContextSelectors
    var props = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, parentProps.slotProps), { active: parentProps.active, variables: parentProps.variables, accessibility: parentProps.accessibility }), inputProps);
    var _b = props.accessibility, accessibility = _b === void 0 ? accessibility_1.menuItemBehavior : _b, children = props.children, content = props.content, icon = props.icon, wrapper = props.wrapper, primary = props.primary, secondary = props.secondary, active = props.active, vertical = props.vertical, indicator = props.indicator, disabled = props.disabled, underlined = props.underlined, iconOnly = props.iconOnly, inSubmenu = props.inSubmenu, pills = props.pills, pointing = props.pointing, className = props.className, design = props.design, styles = props.styles, variables = props.variables;
    var _c = positioner_1.partitionPopperPropsFromShorthand(props.menu), menu = _c[0], positioningProps = _c[1];
    var _d = react_bindings_1.useAutoControlled({
        defaultValue: props.defaultMenuOpen,
        value: props.menuOpen,
        initialValue: false,
    }), menuOpen = _d[0], setMenuOpen = _d[1];
    var _e = React.useState(false), isFromKeyboard = _e[0], setIsFromKeyboard = _e[1];
    var ElementType = react_bindings_1.getElementType(props);
    var unhandledProps = react_bindings_1.useUnhandledProps(composeOptions.handledProps, props);
    var slotProps = composeOptions.resolveSlotProps(tslib_1.__assign(tslib_1.__assign({}, props), { accessibility: accessibility, variables: react_bindings_1.mergeVariablesOverrides(variables, parentProps.variables), isFromKeyboard: isFromKeyboard,
        menuOpen: menuOpen }));
    var getA11yProps = react_bindings_1.useAccessibility(accessibility, {
        debugName: composeOptions.displayName,
        actionHandlers: {
            performClick: function (event) { return !event.defaultPrevented && handleClick(event); },
            openMenu: function (event) { return openMenu(event); },
            closeAllMenusAndFocusNextParentItem: function (event) { return closeAllMenus(event); },
            closeMenu: function (event) { return closeMenu(event); },
            closeMenuAndFocusTrigger: function (event) { return closeMenu(event, true); },
            doNotNavigateNextParentItem: function (event) {
                event.stopPropagation();
            },
            closeAllMenus: function (event) { return closeAllMenus(event); },
        },
        mapPropsToBehavior: function () { return ({
            menuOpen: menuOpen,
            hasMenu: !!menu,
            disabled: disabled,
            vertical: vertical,
            active: active,
        }); },
        rtl: context.rtl,
    });
    var _f = react_bindings_1.useStyles(exports.MenuItem.displayName, {
        className: composeOptions.className,
        mapPropsToStyles: function () { return ({
            primary: primary,
            underlined: underlined,
            active: active,
            vertical: vertical,
            pointing: pointing,
            secondary: secondary,
            disabled: disabled,
            iconOnly: iconOnly,
            pills: pills,
            inSubmenu: inSubmenu,
            isFromKeyboard: isFromKeyboard,
        }); },
        mapPropsToInlineStyles: function () { return ({
            className: className,
            design: design,
            styles: styles,
            variables: react_bindings_1.mergeVariablesOverrides(parentProps.variables, variables),
        }); },
        rtl: context.rtl,
        composeOptions: composeOptions,
        unstable_props: tslib_1.__assign(tslib_1.__assign({}, props), { menuOpen: menuOpen, isFromKeyboard: isFromKeyboard }),
    }), classes = _f.classes, resolvedStyles = _f.styles;
    var menuRef = React.useRef();
    var itemRef = React.useRef();
    var handleWrapperBlur = function (e) {
        if (!props.inSubmenu && !e.currentTarget.contains(e.relatedTarget)) {
            trySetMenuOpen(false, e);
        }
    };
    var outsideClickHandler = function (e) {
        if (!isSubmenuOpen())
            return;
        if (!utils_1.doesNodeContainClick(itemRef.current, e, context.target) &&
            !utils_1.doesNodeContainClick(menuRef.current, e, context.target)) {
            trySetMenuOpen(false, e);
        }
    };
    var performClick = function (e) {
        if (menu) {
            if (utils_1.doesNodeContainClick(menuRef.current, e, context.target)) {
                // submenu was clicked => close it and propagate
                trySetMenuOpen(false, e, function () { return react_bindings_1.focusAsync(itemRef.current); });
            }
            else {
                // the menuItem element was clicked => toggle the open/close and stop propagation
                trySetMenuOpen(active ? !menuOpen : true, e);
                e.stopPropagation();
                e.preventDefault();
            }
        }
    };
    var handleClick = function (e) {
        if (disabled) {
            e.preventDefault();
            return;
        }
        performClick(e);
        _.invoke(tslib_1.__assign({ onClick: parentProps.onItemClick }, props), 'onClick', e, props);
    };
    var handleBlur = function (e) {
        setIsFromKeyboard(false);
        _.invoke(props, 'onBlur', e, props);
    };
    var handleFocus = function (e) {
        setIsFromKeyboard(utils_1.isFromKeyboard());
        _.invoke(props, 'onFocus', e, props);
    };
    var isSubmenuOpen = function () {
        return !!(menu && menuOpen);
    };
    var closeAllMenus = function (e) {
        if (!isSubmenuOpen()) {
            return;
        }
        trySetMenuOpen(false, e, function () {
            if (!inSubmenu) {
                react_bindings_1.focusAsync(itemRef.current);
            }
        });
        // avoid spacebar scrolling the page
        if (!inSubmenu) {
            e.preventDefault();
        }
    };
    var closeMenu = function (e, forceTriggerFocus) {
        if (!isSubmenuOpen()) {
            return;
        }
        var shouldStopPropagation = inSubmenu || props.vertical;
        trySetMenuOpen(false, e, function () {
            if (forceTriggerFocus || shouldStopPropagation) {
                react_bindings_1.focusAsync(itemRef.current);
            }
        });
        if (forceTriggerFocus || shouldStopPropagation) {
            e.stopPropagation();
        }
    };
    var openMenu = function (e) {
        if (menu && !menuOpen) {
            trySetMenuOpen(true, e);
            _.invoke(props, 'onActiveChanged', e, tslib_1.__assign(tslib_1.__assign({}, props), { active: true }));
            e.stopPropagation();
            e.preventDefault();
        }
    };
    var trySetMenuOpen = function (newValue, e, onStateChanged) {
        setMenuOpen(newValue);
        // The reason why post-effect is not passed as callback to trySetState method
        // is that in 'controlled' mode the post-effect is applied before final re-rendering
        // which cause a broken behavior: for e.g. when it is needed to focus submenu trigger on ESC.
        // TODO: all DOM post-effects should be applied at componentDidMount & componentDidUpdated stages.
        onStateChanged && onStateChanged();
        _.invoke(props, 'onMenuOpenChange', e, tslib_1.__assign(tslib_1.__assign({}, props), { menuOpen: newValue }));
    };
    var menuItemInner = (React.createElement(react_component_ref_1.Ref, { innerRef: function (node) {
            itemRef.current = node;
            react_component_ref_1.handleRef(ref, node);
        } },
        React.createElement(ElementType, tslib_1.__assign({}, getA11yProps('root', tslib_1.__assign({ className: classes.root, disabled: disabled, onBlur: handleBlur, onFocus: handleFocus }, unhandledProps)), (!wrapper && { onClick: handleClick })), utils_1.childrenExist(children) ? (children) : (React.createElement(React.Fragment, null,
            utils_1.createShorthand(composeOptions.slots.icon, icon, {
                defaultProps: function () { return getA11yProps('icon', slotProps.icon); },
            }),
            utils_1.createShorthand(composeOptions.slots.content, content, {
                defaultProps: function () { return getA11yProps('content', slotProps.content); },
            }),
            menu &&
                utils_1.createShorthand(composeOptions.slots.indicator, indicator, {
                    defaultProps: function () { return getA11yProps('indicator', slotProps.indicator); },
                }))))));
    var maybeSubmenu = menu && active && menuOpen ? (React.createElement(React.Fragment, null,
        React.createElement(react_component_ref_1.Ref, { innerRef: menuRef },
            React.createElement(positioner_1.Popper, tslib_1.__assign({ align: vertical ? 'top' : context.rtl ? 'end' : 'start', position: vertical ? (context.rtl ? 'before' : 'after') : 'below', targetRef: itemRef }, positioningProps), utils_1.createShorthand(parentProps.menuSlot || composeOptions.slots.menu || Menu_1.Menu, menu, {
                defaultProps: function () { return (tslib_1.__assign(tslib_1.__assign({}, slotProps.menu), { styles: resolvedStyles.menu })); },
            }))),
        React.createElement(react_component_event_listener_1.EventListener, { listener: outsideClickHandler, target: context.target, type: "click" }))) : null;
    if (wrapper) {
        var wrapperElement = utils_1.createShorthand(composeOptions.slots.wrapper, wrapper, {
            defaultProps: function () { return getA11yProps('wrapper', slotProps.wrapper); },
            overrideProps: function () { return ({
                children: (React.createElement(React.Fragment, null,
                    menuItemInner,
                    maybeSubmenu)),
                onClick: handleClick,
                onBlur: handleWrapperBlur,
            }); },
        });
        setEnd();
        return wrapperElement;
    }
    setEnd();
    return menuItemInner;
}, {
    displayName: 'MenuItem',
    className: exports.menuItemClassName,
    slots: {
        icon: MenuItemIcon_1.MenuItemIcon,
        indicator: MenuItemIndicator_1.MenuItemIndicator,
        content: MenuItemContent_1.MenuItemContent,
        wrapper: MenuItemWrapper_1.MenuItemWrapper,
    },
    slotProps: function (props) { return ({
        icon: {
            hasContent: !!props.content,
            iconOnly: props.iconOnly,
        },
        content: {
            hasIcon: !!props.icon,
            hasMenu: !!props.menu,
            inSubmenu: props.inSubmenu,
            vertical: props.vertical,
        },
        indicator: {
            iconOnly: props.iconOnly,
            vertical: props.vertical,
            inSubmenu: props.inSubmenu,
            active: props.active,
            primary: props.primary,
            underlined: props.underlined,
        },
        wrapper: {
            active: props.active,
            disabled: props.disabled,
            iconOnly: props.iconOnly,
            isFromKeyboard: props.isFromKeyboard,
            pills: props.pills,
            pointing: props.pointing,
            secondary: props.secondary,
            underlined: props.underlined,
            vertical: props.vertical,
            primary: props.primary,
        },
        menu: {
            accessibility: accessibility_1.submenuBehavior,
            className: exports.menuItemSlotClassNames.submenu,
            vertical: true,
            primary: props.primary,
            secondary: props.secondary,
            submenu: true,
            indicator: props.indicator,
        },
    }); },
    handledProps: [
        'accessibility',
        'as',
        'children',
        'className',
        'content',
        'design',
        'active',
        'disabled',
        'icon',
        'iconOnly',
        'index',
        'itemPosition',
        'itemsCount',
        'onClick',
        'onFocus',
        'onBlur',
        'pills',
        'pointing',
        'primary',
        'secondary',
        'underlined',
        'vertical',
        'wrapper',
        'menu',
        'menuOpen',
        'defaultMenuOpen',
        'onActiveChanged',
        'inSubmenu',
        'indicator',
        'onMenuOpenChange',
        'styles',
        'variables',
    ],
    shorthandConfig: {
        mappedProp: 'content',
    },
});
exports.MenuItem.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({
    content: 'shorthand',
})), { active: PropTypes.bool, disabled: PropTypes.bool, icon: customPropTypes.shorthandAllowingChildren, iconOnly: PropTypes.bool, index: PropTypes.number, itemPosition: PropTypes.number, itemsCount: PropTypes.number, onClick: PropTypes.func, onFocus: PropTypes.func, onBlur: PropTypes.func, pills: PropTypes.bool, pointing: PropTypes.oneOf(['start', 'end', true, false]), primary: customPropTypes.every([customPropTypes.disallow(['secondary']), PropTypes.bool]), secondary: customPropTypes.every([customPropTypes.disallow(['primary']), PropTypes.bool]), underlined: PropTypes.bool, vertical: PropTypes.bool, wrapper: PropTypes.oneOfType([PropTypes.node, PropTypes.object]), menu: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]), menuOpen: PropTypes.bool, defaultMenuOpen: PropTypes.bool, onActiveChanged: PropTypes.func, inSubmenu: PropTypes.bool, indicator: customPropTypes.shorthandAllowingChildren, onMenuOpenChange: PropTypes.func });
exports.MenuItem.defaultProps = {
    as: 'a',
    wrapper: {},
    indicator: {},
};
