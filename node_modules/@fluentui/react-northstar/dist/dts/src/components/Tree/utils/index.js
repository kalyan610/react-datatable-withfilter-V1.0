"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _ = require("lodash");
var React = require("react");
exports.hasSubtree = function (item) {
    return !_.isNil(item['items']) && item['items'].length > 0;
};
exports.removeItemAtIndex = function (items, itemIndex) {
    return tslib_1.__spreadArrays(items.slice(0, itemIndex), items.slice(itemIndex + 1));
};
exports.getAllSelectableChildrenId = function (items) {
    return items.reduce(function (acc, item) {
        if (item.items) {
            return tslib_1.__spreadArrays(acc, exports.getAllSelectableChildrenId(item.items));
        }
        return item.hasOwnProperty('selectable') && !item.selectable ? acc : tslib_1.__spreadArrays(acc, [item.id]);
    }, []);
};
exports.isAllGroupChecked = function (items, selectedItemIds) {
    var selectableItemIds = exports.getAllSelectableChildrenId(items);
    return selectableItemIds.every(function (id) { return selectedItemIds.indexOf(id) > -1; });
};
/**
 * Looks for the item inside the nested items array and returns its siblings.
 * @param {any[]} items The nested items array.
 * @param {string} itemId The id of the item to return the children of.
 * @returns {any[]} The item siblings
 */
exports.getSiblings = function (items, itemId) {
    function getSiblingsFn(items) {
        var itemIndex = items.findIndex(function (item) { return item.id === itemId; });
        if (itemIndex > -1) {
            return exports.removeItemAtIndex(items, itemIndex);
        }
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var item = items_1[_i];
            if (item.items) {
                var result = getSiblingsFn(item.items);
                if (result) {
                    return result;
                }
            }
        }
        return null;
    }
    return getSiblingsFn(items);
};
exports.processItemsForSelection = function (treeItemProps, selectedItemIds) {
    var treeItemHasSubtree = exports.hasSubtree(treeItemProps);
    var isExpandedSelectableParent = treeItemHasSubtree && treeItemProps.selectableParent && treeItemProps.expanded;
    var nextSelectedItemIds = selectedItemIds;
    // push all tree items under particular parent into selection array
    // not parent itself, therefore not procced with selection
    if (isExpandedSelectableParent) {
        if (exports.isAllGroupChecked(treeItemProps.items, selectedItemIds)) {
            var selectedItems_1 = exports.getAllSelectableChildrenId(treeItemProps.items);
            nextSelectedItemIds = selectedItemIds.filter(function (id) { return selectedItems_1.indexOf(id) === -1; });
        }
        else {
            var selectItems_1 = function (items) {
                items.forEach(function (item) {
                    var selectble = item.hasOwnProperty('selectable') ? item.selectable : treeItemProps.selectable;
                    if (selectedItemIds.indexOf(item.id) === -1) {
                        if (item.items) {
                            selectItems_1(item.items);
                        }
                        else if (selectble) {
                            nextSelectedItemIds.push(item.id);
                        }
                    }
                });
            };
            selectItems_1(treeItemProps.items);
        }
        return tslib_1.__spreadArrays(nextSelectedItemIds);
    }
    // push/remove single tree item into selection array
    if (selectedItemIds.indexOf(treeItemProps.id) === -1) {
        nextSelectedItemIds = tslib_1.__spreadArrays(selectedItemIds, [treeItemProps.id]);
    }
    else {
        nextSelectedItemIds = nextSelectedItemIds.filter(function (itemID) { return itemID !== treeItemProps.id; });
    }
    return nextSelectedItemIds;
};
exports.TreeContext = React.createContext({
    onFocusFirstChild: _.noop,
    onFocusParent: _.noop,
    onSiblingsExpand: _.noop,
    onTitleClick: _.noop,
});
