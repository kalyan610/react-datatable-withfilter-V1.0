"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_context_selector_1 = require("@fluentui/react-context-selector");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var classnames_1 = require("classnames");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var positioner_1 = require("../../utils/positioner");
var utils_1 = require("../../utils");
var Box_1 = require("../Box/Box");
var Label_1 = require("../Label/Label");
var Menu_1 = require("../Menu/Menu");
var Text_1 = require("../Text/Text");
var Reaction_1 = require("../Reaction/Reaction");
var chatItemContext_1 = require("./chatItemContext");
var ChatMessageHeader_1 = require("./ChatMessageHeader");
var ChatMessageDetails_1 = require("./ChatMessageDetails");
exports.chatMessageClassName = 'ui-chat__message';
exports.chatMessageSlotClassNames = {
    actionMenu: exports.chatMessageClassName + "__actions",
    author: exports.chatMessageClassName + "__author",
    timestamp: exports.chatMessageClassName + "__timestamp",
    badge: exports.chatMessageClassName + "__badge",
    content: exports.chatMessageClassName + "__content",
    reactionGroup: exports.chatMessageClassName + "__reactions",
};
/**
 * A ChatMessage represents a single message in chat.
 */
exports.ChatMessage = function (props) {
    var context = react_bindings_1.useFluentContext();
    var _a = react_bindings_1.useTelemetry(exports.ChatMessage.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var parentAttached = react_context_selector_1.useContextSelector(chatItemContext_1.ChatItemContext, function (v) { return v.attached; });
    var accessibility = props.accessibility, _b = props.attached, attached = _b === void 0 ? parentAttached : _b, author = props.author, badge = props.badge, badgePosition = props.badgePosition, children = props.children, className = props.className, content = props.content, design = props.design, mine = props.mine, positionActionMenu = props.positionActionMenu, reactionGroup = props.reactionGroup, reactionGroupPosition = props.reactionGroupPosition, timestamp = props.timestamp, styles = props.styles, variables = props.variables, header = props.header, details = props.details, overflow = props.unstable_overflow;
    var _c = positioner_1.partitionPopperPropsFromShorthand(props.actionMenu), actionMenu = _c[0], positioningProps = _c[1];
    var _d = React.useState(false), focused = _d[0], setFocused = _d[1];
    var _e = React.useState(null), messageNode = _e[0], setMessageNode = _e[1];
    var updateActionsMenuPosition = React.useRef(null);
    var getA11Props = react_bindings_1.useAccessibility(accessibility, {
        actionHandlers: {
            // prevents default FocusZone behavior, e.g., in ChatMessageBehavior, it prevents FocusZone from using arrow keys
            // as navigation (only Tab key should work)
            preventDefault: function (event) {
                // preventDefault only if event coming from inside the message
                if (event.currentTarget !== event.target) {
                    event.preventDefault();
                }
            },
            focus: function (event) {
                if (messageNode) {
                    messageNode.focus();
                    event.stopPropagation();
                }
            },
        },
    });
    var _f = react_bindings_1.useStyles(exports.ChatMessage.displayName, {
        className: exports.chatMessageClassName,
        mapPropsToStyles: function () { return ({
            attached: attached,
            badgePosition: badgePosition,
            focused: focused,
            mine: mine,
            hasBadge: !!badge,
            hasReactionGroup: !!reactionGroup,
        }); },
        mapPropsToInlineStyles: function () { return ({
            className: className,
            design: design,
            styles: styles,
            variables: variables,
        }); },
        rtl: context.rtl,
    }), classes = _f.classes, resolvedStyles = _f.styles;
    var handleFocus = function (e) {
        _.invoke(updateActionsMenuPosition, 'current');
        setFocused(true);
        _.invoke(props, 'onFocus', e, props);
    };
    var handleBlur = function (e) {
        // `focused` controls is focused the whole `ChatMessage` or any of its children. When we're navigating
        // with keyboard the focused element will be changed and there is no way to use `:focus` selector
        var shouldPreserveFocusState = _.invoke(e, 'currentTarget.contains', e.relatedTarget);
        setFocused(shouldPreserveFocusState);
        _.invoke(props, 'onBlur', e, props);
    };
    var handleMouseEnter = function (e) {
        _.invoke(updateActionsMenuPosition, 'current');
        _.invoke(props, 'onMouseEnter', e, props);
    };
    var renderActionMenu = function () {
        var actionMenuElement = Menu_1.Menu.create(actionMenu, {
            defaultProps: function () {
                var _a;
                return (_a = {},
                    _a[accessibility_1.IS_FOCUSABLE_ATTRIBUTE] = true,
                    _a.accessibility = accessibility_1.menuAsToolbarBehavior,
                    _a.className = exports.chatMessageSlotClassNames.actionMenu,
                    _a.styles = resolvedStyles.actionMenu,
                    _a);
            },
        });
        if (!actionMenuElement) {
            return actionMenuElement;
        }
        var modifiers = positionActionMenu && [
            // https://popper.js.org/docs/v2/modifiers/flip/
            // Forces to flip only in "top-*" positions
            { name: 'flip', options: { fallbackPlacements: ['top'] } },
            overflow && {
                name: 'preventOverflow',
                options: { boundary: positioner_1.getScrollParent(messageNode) },
            },
        ];
        return (React.createElement(positioner_1.Popper, tslib_1.__assign({ enabled: positionActionMenu, align: "end", modifiers: modifiers, position: "above", positionFixed: overflow, targetRef: messageNode }, positioningProps), function (_a) {
            var scheduleUpdate = _a.scheduleUpdate;
            updateActionsMenuPosition.current = scheduleUpdate;
            return actionMenuElement;
        }));
    };
    var childrenPropExists = utils_1.childrenExist(children);
    var rootClasses = childrenPropExists ? classnames_1.default(classes.root, classes.content) : classes.root;
    var ElementType = react_bindings_1.getElementType(props);
    var unhandledProps = react_bindings_1.useUnhandledProps(exports.ChatMessage.handledProps, props);
    var badgeElement = Label_1.Label.create(badge, {
        defaultProps: function () { return ({
            className: exports.chatMessageSlotClassNames.badge,
            styles: resolvedStyles.badge,
        }); },
    });
    var reactionGroupElement = Reaction_1.Reaction.Group.create(reactionGroup, {
        defaultProps: function () { return ({
            className: exports.chatMessageSlotClassNames.reactionGroup,
            styles: resolvedStyles.reactionGroup,
        }); },
    });
    var actionMenuElement = renderActionMenu();
    var authorElement = Text_1.Text.create(author, {
        defaultProps: function () { return ({
            size: 'small',
            styles: resolvedStyles.author,
            className: exports.chatMessageSlotClassNames.author,
        }); },
    });
    var timestampElement = Text_1.Text.create(timestamp, {
        defaultProps: function () { return ({
            size: 'small',
            styles: resolvedStyles.timestamp,
            timestamp: true,
            className: exports.chatMessageSlotClassNames.timestamp,
        }); },
    });
    var messageContent = Box_1.Box.create(content, {
        defaultProps: function () { return ({
            className: exports.chatMessageSlotClassNames.content,
            styles: resolvedStyles.content,
        }); },
    });
    var detailsElement = utils_1.createShorthand(ChatMessageDetails_1.ChatMessageDetails, details, {
        defaultProps: function () { return ({ mine: mine }); },
    });
    var headerElement = utils_1.createShorthand(ChatMessageHeader_1.ChatMessageHeader, header || {}, {
        overrideProps: function () { return ({
            content: (React.createElement(React.Fragment, null,
                authorElement,
                timestampElement,
                detailsElement,
                reactionGroupPosition === 'start' && reactionGroupElement)),
        }); },
    });
    var element = (React.createElement(react_component_ref_1.Ref, { innerRef: setMessageNode }, getA11Props.unstable_wrapWithFocusZone(React.createElement(ElementType, tslib_1.__assign({}, getA11Props('root', tslib_1.__assign(tslib_1.__assign({ className: rootClasses, onBlur: handleBlur, onFocus: handleFocus, onMouseEnter: handleMouseEnter }, utils_1.rtlTextContainer.getAttributes({ forElements: [children] })), unhandledProps))), childrenPropExists ? (children) : (React.createElement(React.Fragment, null,
        actionMenuElement,
        badgePosition === 'start' && badgeElement,
        headerElement,
        messageContent,
        reactionGroupPosition === 'end' && reactionGroupElement,
        badgePosition === 'end' && badgeElement))))));
    setEnd();
    return element;
};
exports.ChatMessage.displayName = 'ChatMessage';
exports.ChatMessage.defaultProps = {
    accessibility: accessibility_1.chatMessageBehavior,
    badgePosition: 'end',
    positionActionMenu: true,
    reactionGroupPosition: 'start',
};
exports.ChatMessage.propTypes = tslib_1.__assign(tslib_1.__assign({}, utils_1.commonPropTypes.createCommon({ content: 'shorthand' })), { actionMenu: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]), attached: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['top', 'bottom'])]), author: customPropTypes.itemShorthand, badge: customPropTypes.itemShorthand, details: customPropTypes.itemShorthand, badgePosition: PropTypes.oneOf(['start', 'end']), header: customPropTypes.itemShorthand, mine: PropTypes.bool, timestamp: customPropTypes.itemShorthand, onBlur: PropTypes.func, onFocus: PropTypes.func, onMouseEnter: PropTypes.func, positionActionMenu: PropTypes.bool, reactionGroup: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]), reactionGroupPosition: PropTypes.oneOf(['start', 'end']), unstable_overflow: PropTypes.bool });
exports.ChatMessage.handledProps = Object.keys(exports.ChatMessage.propTypes);
exports.ChatMessage.create = utils_1.createShorthandFactory({ Component: exports.ChatMessage, mappedProp: 'content' });
