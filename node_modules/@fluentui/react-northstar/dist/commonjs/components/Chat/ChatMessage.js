"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.ChatMessage = exports.chatMessageSlotClassNames = exports.chatMessageClassName = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _invoke2 = _interopRequireDefault(require("lodash/invoke"));

var _accessibility = require("@fluentui/accessibility");

var _reactBindings = require("@fluentui/react-bindings");

var _reactContextSelector = require("@fluentui/react-context-selector");

var _reactComponentRef = require("@fluentui/react-component-ref");

var customPropTypes = _interopRequireWildcard(require("@fluentui/react-proptypes"));

var _classnames = _interopRequireDefault(require("classnames"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var React = _interopRequireWildcard(require("react"));

var _positioner = require("../../utils/positioner");

var _utils = require("../../utils");

var _Box = require("../Box/Box");

var _Label = require("../Label/Label");

var _Menu = require("../Menu/Menu");

var _Text = require("../Text/Text");

var _Reaction = require("../Reaction/Reaction");

var _chatItemContext = require("./chatItemContext");

var _ChatMessageHeader = require("./ChatMessageHeader");

var _ChatMessageDetails = require("./ChatMessageDetails");

var chatMessageClassName = 'ui-chat__message';
exports.chatMessageClassName = chatMessageClassName;
var chatMessageSlotClassNames = {
  actionMenu: chatMessageClassName + "__actions",
  author: chatMessageClassName + "__author",
  timestamp: chatMessageClassName + "__timestamp",
  badge: chatMessageClassName + "__badge",
  content: chatMessageClassName + "__content",
  reactionGroup: chatMessageClassName + "__reactions"
};
/**
 * A ChatMessage represents a single message in chat.
 */

exports.chatMessageSlotClassNames = chatMessageSlotClassNames;

var ChatMessage = function ChatMessage(props) {
  var context = (0, _reactBindings.useFluentContext)();

  var _useTelemetry = (0, _reactBindings.useTelemetry)(ChatMessage.displayName, context.telemetry),
      setStart = _useTelemetry.setStart,
      setEnd = _useTelemetry.setEnd;

  setStart();
  var parentAttached = (0, _reactContextSelector.useContextSelector)(_chatItemContext.ChatItemContext, function (v) {
    return v.attached;
  });
  var accessibility = props.accessibility,
      _props$attached = props.attached,
      attached = _props$attached === void 0 ? parentAttached : _props$attached,
      author = props.author,
      badge = props.badge,
      badgePosition = props.badgePosition,
      children = props.children,
      className = props.className,
      content = props.content,
      design = props.design,
      mine = props.mine,
      positionActionMenu = props.positionActionMenu,
      reactionGroup = props.reactionGroup,
      reactionGroupPosition = props.reactionGroupPosition,
      timestamp = props.timestamp,
      styles = props.styles,
      variables = props.variables,
      header = props.header,
      details = props.details,
      overflow = props.unstable_overflow;

  var _partitionPopperProps = (0, _positioner.partitionPopperPropsFromShorthand)(props.actionMenu),
      actionMenu = _partitionPopperProps[0],
      positioningProps = _partitionPopperProps[1];

  var _React$useState = React.useState(false),
      focused = _React$useState[0],
      setFocused = _React$useState[1];

  var _React$useState2 = React.useState(null),
      messageNode = _React$useState2[0],
      setMessageNode = _React$useState2[1];

  var updateActionsMenuPosition = React.useRef(null);
  var getA11Props = (0, _reactBindings.useAccessibility)(accessibility, {
    actionHandlers: {
      // prevents default FocusZone behavior, e.g., in ChatMessageBehavior, it prevents FocusZone from using arrow keys
      // as navigation (only Tab key should work)
      preventDefault: function preventDefault(event) {
        // preventDefault only if event coming from inside the message
        if (event.currentTarget !== event.target) {
          event.preventDefault();
        }
      },
      focus: function focus(event) {
        if (messageNode) {
          messageNode.focus();
          event.stopPropagation();
        }
      }
    }
  });

  var _useStyles = (0, _reactBindings.useStyles)(ChatMessage.displayName, {
    className: chatMessageClassName,
    mapPropsToStyles: function mapPropsToStyles() {
      return {
        attached: attached,
        badgePosition: badgePosition,
        focused: focused,
        mine: mine,
        hasBadge: !!badge,
        hasReactionGroup: !!reactionGroup
      };
    },
    mapPropsToInlineStyles: function mapPropsToInlineStyles() {
      return {
        className: className,
        design: design,
        styles: styles,
        variables: variables
      };
    },
    rtl: context.rtl
  }),
      classes = _useStyles.classes,
      resolvedStyles = _useStyles.styles;

  var handleFocus = function handleFocus(e) {
    (0, _invoke2.default)(updateActionsMenuPosition, 'current');
    setFocused(true);
    (0, _invoke2.default)(props, 'onFocus', e, props);
  };

  var handleBlur = function handleBlur(e) {
    // `focused` controls is focused the whole `ChatMessage` or any of its children. When we're navigating
    // with keyboard the focused element will be changed and there is no way to use `:focus` selector
    var shouldPreserveFocusState = (0, _invoke2.default)(e, 'currentTarget.contains', e.relatedTarget);
    setFocused(shouldPreserveFocusState);
    (0, _invoke2.default)(props, 'onBlur', e, props);
  };

  var handleMouseEnter = function handleMouseEnter(e) {
    (0, _invoke2.default)(updateActionsMenuPosition, 'current');
    (0, _invoke2.default)(props, 'onMouseEnter', e, props);
  };

  var renderActionMenu = function renderActionMenu() {
    var actionMenuElement = _Menu.Menu.create(actionMenu, {
      defaultProps: function defaultProps() {
        var _ref;

        return _ref = {}, _ref[_accessibility.IS_FOCUSABLE_ATTRIBUTE] = true, _ref.accessibility = _accessibility.menuAsToolbarBehavior, _ref.className = chatMessageSlotClassNames.actionMenu, _ref.styles = resolvedStyles.actionMenu, _ref;
      }
    });

    if (!actionMenuElement) {
      return actionMenuElement;
    }

    var modifiers = positionActionMenu && [// https://popper.js.org/docs/v2/modifiers/flip/
    // Forces to flip only in "top-*" positions
    {
      name: 'flip',
      options: {
        fallbackPlacements: ['top']
      }
    }, overflow && {
      name: 'preventOverflow',
      options: {
        boundary: (0, _positioner.getScrollParent)(messageNode)
      }
    }];
    return /*#__PURE__*/React.createElement(_positioner.Popper, (0, _extends2.default)({
      enabled: positionActionMenu,
      align: "end",
      modifiers: modifiers,
      position: "above",
      positionFixed: overflow,
      targetRef: messageNode
    }, positioningProps), function (_ref2) {
      var scheduleUpdate = _ref2.scheduleUpdate;
      updateActionsMenuPosition.current = scheduleUpdate;
      return actionMenuElement;
    });
  };

  var childrenPropExists = (0, _utils.childrenExist)(children);
  var rootClasses = childrenPropExists ? (0, _classnames.default)(classes.root, classes.content) : classes.root;
  var ElementType = (0, _reactBindings.getElementType)(props);
  var unhandledProps = (0, _reactBindings.useUnhandledProps)(ChatMessage.handledProps, props);

  var badgeElement = _Label.Label.create(badge, {
    defaultProps: function defaultProps() {
      return {
        className: chatMessageSlotClassNames.badge,
        styles: resolvedStyles.badge
      };
    }
  });

  var reactionGroupElement = _Reaction.Reaction.Group.create(reactionGroup, {
    defaultProps: function defaultProps() {
      return {
        className: chatMessageSlotClassNames.reactionGroup,
        styles: resolvedStyles.reactionGroup
      };
    }
  });

  var actionMenuElement = renderActionMenu();

  var authorElement = _Text.Text.create(author, {
    defaultProps: function defaultProps() {
      return {
        size: 'small',
        styles: resolvedStyles.author,
        className: chatMessageSlotClassNames.author
      };
    }
  });

  var timestampElement = _Text.Text.create(timestamp, {
    defaultProps: function defaultProps() {
      return {
        size: 'small',
        styles: resolvedStyles.timestamp,
        timestamp: true,
        className: chatMessageSlotClassNames.timestamp
      };
    }
  });

  var messageContent = _Box.Box.create(content, {
    defaultProps: function defaultProps() {
      return {
        className: chatMessageSlotClassNames.content,
        styles: resolvedStyles.content
      };
    }
  });

  var detailsElement = (0, _utils.createShorthand)(_ChatMessageDetails.ChatMessageDetails, details, {
    defaultProps: function defaultProps() {
      return {
        mine: mine
      };
    }
  });
  var headerElement = (0, _utils.createShorthand)(_ChatMessageHeader.ChatMessageHeader, header || {}, {
    overrideProps: function overrideProps() {
      return {
        content: /*#__PURE__*/React.createElement(React.Fragment, null, authorElement, timestampElement, detailsElement, reactionGroupPosition === 'start' && reactionGroupElement)
      };
    }
  });
  var element = /*#__PURE__*/React.createElement(_reactComponentRef.Ref, {
    innerRef: setMessageNode
  }, getA11Props.unstable_wrapWithFocusZone( /*#__PURE__*/React.createElement(ElementType, getA11Props('root', Object.assign({
    className: rootClasses,
    onBlur: handleBlur,
    onFocus: handleFocus,
    onMouseEnter: handleMouseEnter
  }, _utils.rtlTextContainer.getAttributes({
    forElements: [children]
  }), unhandledProps)), childrenPropExists ? children : /*#__PURE__*/React.createElement(React.Fragment, null, actionMenuElement, badgePosition === 'start' && badgeElement, headerElement, messageContent, reactionGroupPosition === 'end' && reactionGroupElement, badgePosition === 'end' && badgeElement))));
  setEnd();
  return element;
};

exports.ChatMessage = ChatMessage;
ChatMessage.displayName = 'ChatMessage';
ChatMessage.defaultProps = {
  accessibility: _accessibility.chatMessageBehavior,
  badgePosition: 'end',
  positionActionMenu: true,
  reactionGroupPosition: 'start'
};
ChatMessage.propTypes = Object.assign({}, _utils.commonPropTypes.createCommon({
  content: 'shorthand'
}), {
  actionMenu: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]),
  attached: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['top', 'bottom'])]),
  author: customPropTypes.itemShorthand,
  badge: customPropTypes.itemShorthand,
  details: customPropTypes.itemShorthand,
  badgePosition: PropTypes.oneOf(['start', 'end']),
  header: customPropTypes.itemShorthand,
  mine: PropTypes.bool,
  timestamp: customPropTypes.itemShorthand,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  onMouseEnter: PropTypes.func,
  positionActionMenu: PropTypes.bool,
  reactionGroup: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]),
  reactionGroupPosition: PropTypes.oneOf(['start', 'end']),
  unstable_overflow: PropTypes.bool
});
ChatMessage.handledProps = Object.keys(ChatMessage.propTypes);
ChatMessage.create = (0, _utils.createShorthandFactory)({
  Component: ChatMessage,
  mappedProp: 'content'
});
//# sourceMappingURL=ChatMessage.js.map
