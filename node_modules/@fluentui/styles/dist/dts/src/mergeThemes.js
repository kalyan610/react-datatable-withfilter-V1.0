"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _ = require("lodash");
var callable_1 = require("./callable");
var debugEnabled_1 = require("./debugEnabled");
var deepmerge_1 = require("./deepmerge");
var objectKeysToValues_1 = require("./objectKeysToValues");
var toCompactArray_1 = require("./toCompactArray");
var withDebugId_1 = require("./withDebugId");
exports.emptyTheme = {
    siteVariables: {
        fontSizes: {},
    },
    componentVariables: {},
    componentStyles: {},
    fontFaces: [],
    staticStyles: [],
    animations: {},
};
// ----------------------------------------
// Component level merge functions
// ----------------------------------------
/**
 * Merges a single component's styles (keyed by component part) with another component's styles.
 */
exports.mergeComponentStyles__PROD = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    var initial = {};
    return sources.reduce(function (partStylesPrepared, stylesByPart) {
        // The of "[].forEach()" instead of "_.forEach" has zero sense, but somehow it solves a reported memory leak.
        // There is no 100% confidence that it actually fixes anything.
        if (_.isPlainObject(stylesByPart)) {
            Object.keys(stylesByPart).forEach(function (partName) {
                var partStyle = stylesByPart[partName];
                // Break references to avoid an infinite loop.
                // We are replacing functions with a new ones that calls the originals.
                var originalTarget = partStylesPrepared[partName];
                var originalSource = partStyle;
                // if there is no source, merging is a no-op, skip it
                if (typeof originalSource === 'undefined' ||
                    originalSource === null ||
                    (typeof originalSource === 'object' && Object.keys(originalSource).length === 0)) {
                    return;
                }
                // no target means source doesn't need to merge onto anything
                // just ensure source is callable (prepared format)
                if (typeof originalTarget === 'undefined') {
                    partStylesPrepared[partName] = callable_1.callable(originalSource);
                    return;
                }
                // We have both target and source, replace with merge fn
                partStylesPrepared[partName] = function (styleParam) {
                    // originalTarget is always prepared, fn is guaranteed
                    return _.merge(originalTarget(styleParam), callable_1.callable(originalSource)(styleParam));
                };
            });
        }
        return partStylesPrepared;
    }, initial);
};
exports.mergeComponentStyles__DEV = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (!debugEnabled_1.isEnabled) {
        return exports.mergeComponentStyles__PROD.apply(void 0, sources);
    }
    var initial = {};
    return sources.reduce(function (partStylesPrepared, stylesByPart) {
        _.forEach(stylesByPart, function (partStyle, partName) {
            // Break references to avoid an infinite loop.
            // We are replacing functions with a new ones that calls the originals.
            var originalTarget = partStylesPrepared[partName];
            var originalSource = partStyle;
            // if there is no source, merging is a no-op, skip it
            if (typeof originalSource === 'undefined' ||
                originalSource === null ||
                (typeof originalSource === 'object' && Object.keys(originalSource).length === 0)) {
                return;
            }
            // no target means source doesn't need to merge onto anything
            // just ensure source is callable (prepared format) and has _debug
            if (typeof originalTarget === 'undefined') {
                partStylesPrepared[partName] = function (styleParam) {
                    // originalTarget is always prepared, fn is guaranteed, _debug always exists
                    var _a = callable_1.callable(originalSource)(styleParam) || {}, _b = _a._debug, _debug = _b === void 0 ? undefined : _b, styles = tslib_1.__rest(_a, ["_debug"]);
                    // new object required to prevent circular JSON structure error in <Debug />
                    return tslib_1.__assign(tslib_1.__assign({}, styles), { _debug: _debug || [{ styles: tslib_1.__assign({}, styles), debugId: stylesByPart._debugId }] });
                };
                return;
            }
            // We have both target and source, replace with merge fn
            partStylesPrepared[partName] = function (styleParam) {
                // originalTarget is always prepared, fn is guaranteed, _debug always exists
                var _a = originalTarget(styleParam), targetDebug = _a._debug, targetStyles = tslib_1.__rest(_a, ["_debug"]);
                var _b = callable_1.callable(originalSource)(styleParam) || {}, _c = _b._debug, sourceDebug = _c === void 0 ? undefined : _c, sourceStyles = tslib_1.__rest(_b, ["_debug"]);
                var merged = _.merge(targetStyles, sourceStyles);
                merged._debug = targetDebug.concat(sourceDebug || { styles: sourceStyles, debugId: stylesByPart._debugId });
                return merged;
            };
        });
        return partStylesPrepared;
    }, initial);
};
exports.mergeComponentStyles = process.env.NODE_ENV === 'production' ? exports.mergeComponentStyles__PROD : exports.mergeComponentStyles__DEV;
/**
 * Merges a single component's variables with another component's variables.
 */
exports.mergeComponentVariables__PROD = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    var initial = function () { return ({}); };
    // filtering is required as some arguments can be undefined
    var filteredSources = sources.filter(Boolean);
    // a short circle to avoid calls of deepmerge()
    if (filteredSources.length === 1) {
        return typeof filteredSources[0] === 'function' ? filteredSources[0] : callable_1.callable(filteredSources[0]);
    }
    return filteredSources.reduce(function (acc, next) {
        return function mergeComponentVariables() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var accumulatedVariables = acc.apply(void 0, args);
            var fn = typeof next === 'function' ? next : callable_1.callable(next);
            var computedComponentVariables = fn.apply(void 0, args);
            return deepmerge_1.deepmerge(accumulatedVariables, computedComponentVariables);
        };
    }, initial);
};
exports.mergeComponentVariables__DEV = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (!debugEnabled_1.isEnabled) {
        return exports.mergeComponentVariables__PROD.apply(void 0, sources);
    }
    var initial = function () { return ({}); };
    return sources.reduce(function (acc, next) {
        return function (siteVariables) {
            var _a = acc(siteVariables), _b = _a._debug, _debug = _b === void 0 ? [] : _b, accumulatedVariables = tslib_1.__rest(_a, ["_debug"]);
            var _c = callable_1.callable(next)(siteVariables) || {}, _d = _c._debug, computedDebug = _d === void 0 ? undefined : _d, _e = _c._debugId, _debugId = _e === void 0 ? undefined : _e, computedComponentVariables = tslib_1.__rest(_c, ["_debug", "_debugId"]);
            var merged = deepmerge_1.deepmerge(accumulatedVariables, computedComponentVariables);
            merged._debug = _debug.concat(computedDebug || {
                resolved: computedComponentVariables,
                debugId: _debugId,
                input: siteVariables
                    ? siteVariables._invertedKeys && callable_1.callable(next)(siteVariables._invertedKeys)
                    : callable_1.callable(next)(),
            });
            return merged;
        };
    }, initial);
};
exports.mergeComponentVariables = process.env.NODE_ENV === 'production' ? exports.mergeComponentVariables__PROD : exports.mergeComponentVariables__DEV;
// ----------------------------------------
// Theme level merge functions
// ----------------------------------------
/**
 * Site variables can safely be merged at each Provider in the tree.
 * They are flat objects and do not depend on render-time values, such as props.
 */
exports.mergeSiteVariables__PROD = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    var initial = {
        fontSizes: {},
    };
    return deepmerge_1.deepmerge.apply(void 0, tslib_1.__spreadArrays([initial], sources));
};
exports.mergeSiteVariables__DEV = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (!debugEnabled_1.isEnabled) {
        return exports.mergeSiteVariables__PROD.apply(void 0, sources);
    }
    var initial = {
        fontSizes: {},
    };
    return sources.reduce(function (acc, next) {
        var _a = acc._debug, _debug = _a === void 0 ? [] : _a, accumulatedSiteVariables = tslib_1.__rest(acc, ["_debug"]);
        var _b = next || {}, _c = _b._debug, computedDebug = _c === void 0 ? undefined : _c, _d = _b._invertedKeys, _invertedKeys = _d === void 0 ? undefined : _d, _e = _b._debugId, _debugId = _e === void 0 ? undefined : _e, nextSiteVariables = tslib_1.__rest(_b, ["_debug", "_invertedKeys", "_debugId"]);
        var merged = deepmerge_1.deepmerge(tslib_1.__assign(tslib_1.__assign({}, accumulatedSiteVariables), { _invertedKeys: undefined }), nextSiteVariables);
        merged._debug = _debug.concat(computedDebug || { resolved: nextSiteVariables, debugId: _debugId });
        merged._invertedKeys = _invertedKeys || objectKeysToValues_1.objectKeyToValues(merged, function (key) { return "siteVariables." + key; });
        return merged;
    }, initial);
};
exports.mergeSiteVariables = process.env.NODE_ENV === 'production' ? exports.mergeSiteVariables__PROD : exports.mergeSiteVariables__DEV;
/**
 * Component variables can be objects, functions, or an array of these.
 * The functions must be called with the final result of siteVariables, otherwise
 *   the component variable objects would have no ability to apply siteVariables.
 * Therefore, componentVariables must be resolved by the component at render time.
 * We instead pass down call stack of component variable functions to be resolved later.
 */
exports.mergeThemeVariables__PROD = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    var displayNames = _.union.apply(_, _.map(sources, _.keys));
    return displayNames.reduce(function (componentVariables, displayName) {
        componentVariables[displayName] = exports.mergeComponentVariables.apply(void 0, _.map(sources, displayName));
        return componentVariables;
    }, {});
};
exports.mergeThemeVariables__DEV = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (!debugEnabled_1.isEnabled) {
        return exports.mergeThemeVariables__PROD.apply(void 0, sources);
    }
    var displayNames = _.union.apply(_, _.map(sources, _.keys));
    return displayNames.reduce(function (componentVariables, displayName) {
        componentVariables[displayName] = exports.mergeComponentVariables.apply(void 0, _.map(sources, function (source) { return source && withDebugId_1.withDebugId(source[displayName], source._debugId); }));
        return componentVariables;
    }, {});
};
exports.mergeThemeVariables = process.env.NODE_ENV === 'production' ? exports.mergeThemeVariables__PROD : exports.mergeThemeVariables__DEV;
/**
 * See mergeThemeVariables() description.
 * Component styles adhere to the same pattern as component variables, except
 *   that they return style objects.
 */
exports.mergeThemeStyles = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    var initial = {};
    return sources.reduce(function (themeComponentStyles, next) {
        _.forEach(next, function (stylesByPart, displayName) {
            themeComponentStyles[displayName] = exports.mergeComponentStyles(themeComponentStyles[displayName], withDebugId_1.withDebugId(stylesByPart, next._debugId));
        });
        return themeComponentStyles;
    }, initial);
};
exports.mergeFontFaces = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return toCompactArray_1.toCompactArray.apply(void 0, sources);
};
exports.mergeStaticStyles = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return toCompactArray_1.toCompactArray.apply(void 0, sources);
};
exports.mergeAnimations = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return Object.assign.apply(Object, tslib_1.__spreadArrays([{}], sources));
};
exports.mergeStyles = function () {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return sources.reduce(function (acc, next) {
            return _.merge(acc, callable_1.callable(next).apply(void 0, args));
        }, {});
    };
};
exports.mergeThemes = function () {
    var themes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        themes[_i] = arguments[_i];
    }
    return themes.reduce(function (acc, next) {
        if (!next)
            return acc;
        var nextDebugId = next['_debugId'];
        acc.siteVariables = exports.mergeSiteVariables(acc.siteVariables, withDebugId_1.withDebugId(next.siteVariables, nextDebugId));
        acc.componentVariables = exports.mergeThemeVariables(acc.componentVariables, withDebugId_1.withDebugId(next.componentVariables, nextDebugId));
        acc.componentStyles = exports.mergeThemeStyles(acc.componentStyles, withDebugId_1.withDebugId(next.componentStyles, nextDebugId));
        acc.fontFaces = exports.mergeFontFaces.apply(void 0, tslib_1.__spreadArrays(acc.fontFaces, (next.fontFaces || [])));
        acc.staticStyles = exports.mergeStaticStyles.apply(void 0, tslib_1.__spreadArrays(acc.staticStyles, (next.staticStyles || [])));
        acc.animations = exports.mergeAnimations(acc.animations, next.animations);
        return acc;
    }, tslib_1.__assign({}, exports.emptyTheme));
};
