import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _keys from "lodash/keys";
import _map from "lodash/map";
import _union from "lodash/union";
import _forEach from "lodash/forEach";
import _merge from "lodash/merge";
import _isPlainObject from "lodash/isPlainObject";
import { callable } from './callable';
import { isEnabled as isDebugEnabled } from './debugEnabled';
import { deepmerge } from './deepmerge';
import { objectKeyToValues } from './objectKeysToValues';
import { toCompactArray } from './toCompactArray';
import { withDebugId } from './withDebugId';
export var emptyTheme = {
  siteVariables: {
    fontSizes: {}
  },
  componentVariables: {},
  componentStyles: {},
  fontFaces: [],
  staticStyles: [],
  animations: {}
}; // ----------------------------------------
// Component level merge functions
// ----------------------------------------

/**
 * Merges a single component's styles (keyed by component part) with another component's styles.
 */

export var mergeComponentStyles__PROD = function mergeComponentStyles__PROD() {
  var initial = {};

  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }

  return sources.reduce(function (partStylesPrepared, stylesByPart) {
    // The of "[].forEach()" instead of "_.forEach" has zero sense, but somehow it solves a reported memory leak.
    // There is no 100% confidence that it actually fixes anything.
    if (_isPlainObject(stylesByPart)) {
      Object.keys(stylesByPart).forEach(function (partName) {
        var partStyle = stylesByPart[partName]; // Break references to avoid an infinite loop.
        // We are replacing functions with a new ones that calls the originals.

        var originalTarget = partStylesPrepared[partName];
        var originalSource = partStyle; // if there is no source, merging is a no-op, skip it

        if (typeof originalSource === 'undefined' || originalSource === null || typeof originalSource === 'object' && Object.keys(originalSource).length === 0) {
          return;
        } // no target means source doesn't need to merge onto anything
        // just ensure source is callable (prepared format)


        if (typeof originalTarget === 'undefined') {
          partStylesPrepared[partName] = callable(originalSource);
          return;
        } // We have both target and source, replace with merge fn


        partStylesPrepared[partName] = function (styleParam) {
          // originalTarget is always prepared, fn is guaranteed
          return _merge(originalTarget(styleParam), callable(originalSource)(styleParam));
        };
      });
    }

    return partStylesPrepared;
  }, initial);
};
export var mergeComponentStyles__DEV = function mergeComponentStyles__DEV() {
  for (var _len2 = arguments.length, sources = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    sources[_key2] = arguments[_key2];
  }

  if (!isDebugEnabled) {
    return mergeComponentStyles__PROD.apply(void 0, sources);
  }

  var initial = {};
  return sources.reduce(function (partStylesPrepared, stylesByPart) {
    _forEach(stylesByPart, function (partStyle, partName) {
      // Break references to avoid an infinite loop.
      // We are replacing functions with a new ones that calls the originals.
      var originalTarget = partStylesPrepared[partName];
      var originalSource = partStyle; // if there is no source, merging is a no-op, skip it

      if (typeof originalSource === 'undefined' || originalSource === null || typeof originalSource === 'object' && Object.keys(originalSource).length === 0) {
        return;
      } // no target means source doesn't need to merge onto anything
      // just ensure source is callable (prepared format) and has _debug


      if (typeof originalTarget === 'undefined') {
        partStylesPrepared[partName] = function (styleParam) {
          // originalTarget is always prepared, fn is guaranteed, _debug always exists
          var _ref = callable(originalSource)(styleParam) || {},
              _ref$_debug = _ref._debug,
              _debug = _ref$_debug === void 0 ? undefined : _ref$_debug,
              styles = _objectWithoutPropertiesLoose(_ref, ["_debug"]); // new object required to prevent circular JSON structure error in <Debug />


          return Object.assign({}, styles, {
            _debug: _debug || [{
              styles: Object.assign({}, styles),
              debugId: stylesByPart._debugId
            }]
          });
        };

        return;
      } // We have both target and source, replace with merge fn


      partStylesPrepared[partName] = function (styleParam) {
        // originalTarget is always prepared, fn is guaranteed, _debug always exists
        var _originalTarget = originalTarget(styleParam),
            targetDebug = _originalTarget._debug,
            targetStyles = _objectWithoutPropertiesLoose(_originalTarget, ["_debug"]);

        var _ref2 = callable(originalSource)(styleParam) || {},
            _ref2$_debug = _ref2._debug,
            sourceDebug = _ref2$_debug === void 0 ? undefined : _ref2$_debug,
            sourceStyles = _objectWithoutPropertiesLoose(_ref2, ["_debug"]);

        var merged = _merge(targetStyles, sourceStyles);

        merged._debug = targetDebug.concat(sourceDebug || {
          styles: sourceStyles,
          debugId: stylesByPart._debugId
        });
        return merged;
      };
    });

    return partStylesPrepared;
  }, initial);
};
export var mergeComponentStyles = process.env.NODE_ENV === 'production' ? mergeComponentStyles__PROD : mergeComponentStyles__DEV;
/**
 * Merges a single component's variables with another component's variables.
 */

export var mergeComponentVariables__PROD = function mergeComponentVariables__PROD() {
  var initial = function initial() {
    return {};
  }; // filtering is required as some arguments can be undefined


  for (var _len3 = arguments.length, sources = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    sources[_key3] = arguments[_key3];
  }

  var filteredSources = sources.filter(Boolean); // a short circle to avoid calls of deepmerge()

  if (filteredSources.length === 1) {
    return typeof filteredSources[0] === 'function' ? filteredSources[0] : callable(filteredSources[0]);
  }

  return filteredSources.reduce(function (acc, next) {
    return function mergeComponentVariables() {
      var accumulatedVariables = acc.apply(void 0, arguments);
      var fn = typeof next === 'function' ? next : callable(next);
      var computedComponentVariables = fn.apply(void 0, arguments);
      return deepmerge(accumulatedVariables, computedComponentVariables);
    };
  }, initial);
};
export var mergeComponentVariables__DEV = function mergeComponentVariables__DEV() {
  for (var _len4 = arguments.length, sources = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    sources[_key4] = arguments[_key4];
  }

  if (!isDebugEnabled) {
    return mergeComponentVariables__PROD.apply(void 0, sources);
  }

  var initial = function initial() {
    return {};
  };

  return sources.reduce(function (acc, next) {
    return function (siteVariables) {
      var _acc = acc(siteVariables),
          _acc$_debug = _acc._debug,
          _debug = _acc$_debug === void 0 ? [] : _acc$_debug,
          accumulatedVariables = _objectWithoutPropertiesLoose(_acc, ["_debug"]);

      var _ref3 = callable(next)(siteVariables) || {},
          _ref3$_debug = _ref3._debug,
          computedDebug = _ref3$_debug === void 0 ? undefined : _ref3$_debug,
          _ref3$_debugId = _ref3._debugId,
          _debugId = _ref3$_debugId === void 0 ? undefined : _ref3$_debugId,
          computedComponentVariables = _objectWithoutPropertiesLoose(_ref3, ["_debug", "_debugId"]);

      var merged = deepmerge(accumulatedVariables, computedComponentVariables);
      merged._debug = _debug.concat(computedDebug || {
        resolved: computedComponentVariables,
        debugId: _debugId,
        input: siteVariables ? siteVariables._invertedKeys && callable(next)(siteVariables._invertedKeys) : callable(next)()
      });
      return merged;
    };
  }, initial);
};
export var mergeComponentVariables = process.env.NODE_ENV === 'production' ? mergeComponentVariables__PROD : mergeComponentVariables__DEV; // ----------------------------------------
// Theme level merge functions
// ----------------------------------------

/**
 * Site variables can safely be merged at each Provider in the tree.
 * They are flat objects and do not depend on render-time values, such as props.
 */

export var mergeSiteVariables__PROD = function mergeSiteVariables__PROD() {
  var initial = {
    fontSizes: {}
  };

  for (var _len5 = arguments.length, sources = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    sources[_key5] = arguments[_key5];
  }

  return deepmerge.apply(void 0, [initial].concat(sources));
};
export var mergeSiteVariables__DEV = function mergeSiteVariables__DEV() {
  for (var _len6 = arguments.length, sources = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    sources[_key6] = arguments[_key6];
  }

  if (!isDebugEnabled) {
    return mergeSiteVariables__PROD.apply(void 0, sources);
  }

  var initial = {
    fontSizes: {}
  };
  return sources.reduce(function (acc, next) {
    var _acc$_debug2 = acc._debug,
        _debug = _acc$_debug2 === void 0 ? [] : _acc$_debug2,
        accumulatedSiteVariables = _objectWithoutPropertiesLoose(acc, ["_debug"]);

    var _ref4 = next || {},
        _ref4$_debug = _ref4._debug,
        computedDebug = _ref4$_debug === void 0 ? undefined : _ref4$_debug,
        _ref4$_invertedKeys = _ref4._invertedKeys,
        _invertedKeys = _ref4$_invertedKeys === void 0 ? undefined : _ref4$_invertedKeys,
        _ref4$_debugId = _ref4._debugId,
        _debugId = _ref4$_debugId === void 0 ? undefined : _ref4$_debugId,
        nextSiteVariables = _objectWithoutPropertiesLoose(_ref4, ["_debug", "_invertedKeys", "_debugId"]);

    var merged = deepmerge(Object.assign({}, accumulatedSiteVariables, {
      _invertedKeys: undefined
    }), nextSiteVariables);
    merged._debug = _debug.concat(computedDebug || {
      resolved: nextSiteVariables,
      debugId: _debugId
    });
    merged._invertedKeys = _invertedKeys || objectKeyToValues(merged, function (key) {
      return "siteVariables." + key;
    });
    return merged;
  }, initial);
};
export var mergeSiteVariables = process.env.NODE_ENV === 'production' ? mergeSiteVariables__PROD : mergeSiteVariables__DEV;
/**
 * Component variables can be objects, functions, or an array of these.
 * The functions must be called with the final result of siteVariables, otherwise
 *   the component variable objects would have no ability to apply siteVariables.
 * Therefore, componentVariables must be resolved by the component at render time.
 * We instead pass down call stack of component variable functions to be resolved later.
 */

export var mergeThemeVariables__PROD = function mergeThemeVariables__PROD() {
  for (var _len7 = arguments.length, sources = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    sources[_key7] = arguments[_key7];
  }

  var displayNames = _union.apply(void 0, _map(sources, _keys));

  return displayNames.reduce(function (componentVariables, displayName) {
    componentVariables[displayName] = mergeComponentVariables.apply(void 0, _map(sources, displayName));
    return componentVariables;
  }, {});
};
export var mergeThemeVariables__DEV = function mergeThemeVariables__DEV() {
  for (var _len8 = arguments.length, sources = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
    sources[_key8] = arguments[_key8];
  }

  if (!isDebugEnabled) {
    return mergeThemeVariables__PROD.apply(void 0, sources);
  }

  var displayNames = _union.apply(void 0, _map(sources, _keys));

  return displayNames.reduce(function (componentVariables, displayName) {
    componentVariables[displayName] = mergeComponentVariables.apply(void 0, _map(sources, function (source) {
      return source && withDebugId(source[displayName], source._debugId);
    }));
    return componentVariables;
  }, {});
};
export var mergeThemeVariables = process.env.NODE_ENV === 'production' ? mergeThemeVariables__PROD : mergeThemeVariables__DEV;
/**
 * See mergeThemeVariables() description.
 * Component styles adhere to the same pattern as component variables, except
 *   that they return style objects.
 */

export var mergeThemeStyles = function mergeThemeStyles() {
  var initial = {};

  for (var _len9 = arguments.length, sources = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    sources[_key9] = arguments[_key9];
  }

  return sources.reduce(function (themeComponentStyles, next) {
    _forEach(next, function (stylesByPart, displayName) {
      themeComponentStyles[displayName] = mergeComponentStyles(themeComponentStyles[displayName], withDebugId(stylesByPart, next._debugId));
    });

    return themeComponentStyles;
  }, initial);
};
export var mergeFontFaces = function mergeFontFaces() {
  return toCompactArray.apply(void 0, arguments);
};
export var mergeStaticStyles = function mergeStaticStyles() {
  return toCompactArray.apply(void 0, arguments);
};
export var mergeAnimations = function mergeAnimations() {
  for (var _len10 = arguments.length, sources = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
    sources[_key10] = arguments[_key10];
  }

  return Object.assign.apply(Object, [{}].concat(sources));
};
export var mergeStyles = function mergeStyles() {
  for (var _len11 = arguments.length, sources = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
    sources[_key11] = arguments[_key11];
  }

  return function () {
    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }

    return sources.reduce(function (acc, next) {
      return _merge(acc, callable(next).apply(void 0, args));
    }, {});
  };
};
export var mergeThemes = function mergeThemes() {
  for (var _len13 = arguments.length, themes = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
    themes[_key13] = arguments[_key13];
  }

  return themes.reduce(function (acc, next) {
    if (!next) return acc;
    var nextDebugId = next['_debugId'];
    acc.siteVariables = mergeSiteVariables(acc.siteVariables, withDebugId(next.siteVariables, nextDebugId));
    acc.componentVariables = mergeThemeVariables(acc.componentVariables, withDebugId(next.componentVariables, nextDebugId));
    acc.componentStyles = mergeThemeStyles(acc.componentStyles, withDebugId(next.componentStyles, nextDebugId));
    acc.fontFaces = mergeFontFaces.apply(void 0, acc.fontFaces.concat(next.fontFaces || []));
    acc.staticStyles = mergeStaticStyles.apply(void 0, acc.staticStyles.concat(next.staticStyles || []));
    acc.animations = mergeAnimations(acc.animations, next.animations);
    return acc;
  }, // .reduce() will modify "emptyTheme" object, so we should clone it before actual usage
  Object.assign({}, emptyTheme));
};
//# sourceMappingURL=mergeThemes.js.map
