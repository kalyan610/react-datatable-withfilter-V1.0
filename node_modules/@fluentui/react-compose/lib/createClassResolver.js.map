{"version":3,"file":"createClassResolver.js","sourceRoot":"../src/","sources":["createClassResolver.ts"],"names":[],"mappings":"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","sourcesContent":["import { GenericDictionary, ClassDictionary } from './types';\nimport { appendClasses } from './appendClasses';\n\n/**\n * `createClassResolver` is a factory function which creates a state to classmap resolver for\n * slot specific class names. It can be used in conjunction with the `compose` option `classes` to\n * inject css modules without writing cx(...) logic manually distributing classnames.\n *\n * Class names which map to slots are automatically distributed to correct slot props.\n *\n * Class names with an underscore are interpretted as enum matchable classes. For example,\n * the class \"size_large\" would be applied to the `root` slot when the component's state contains\n * a prop `size` with a value `large`.\n *\n * Remaining class names would be interpretted as modifiers, applied to the `root` slot when\n * the component `state` contains a truthy matching prop name.\n */\nexport const createClassResolver = (classes: ClassDictionary) => {\n  // This is in creation time, so this will happen once per css file.\n  const { slots, modifiers, enums } = createResolvedMap(classes);\n\n  // Everything in the function below will happen at runtime, so it's very critical that this\n  // code is as minimal as possible.\n  return function classResolver(state: GenericDictionary): ClassDictionary {\n    const resolvedClasses: Record<string, string> = {};\n\n    let modifierClasses = '';\n    for (const modifierName of Object.keys(modifiers)) {\n      if (state[modifierName]) {\n        modifierClasses = appendClasses(modifierClasses, modifiers[modifierName]);\n      }\n    }\n\n    let enumClasses = '';\n    for (const enumName of Object.keys(enums)) {\n      const enumValues = enums[enumName];\n      // if we have a class which matches the enumName and current state value, add it.\n      if (enumValues[state[enumName]]) {\n        enumClasses = appendClasses(enumClasses, enumValues[state[enumName]]);\n      }\n    }\n\n    for (const slotName of Object.keys(slots)) {\n      resolvedClasses[slotName] = appendClasses(slots[slotName], modifierClasses, enumClasses);\n    }\n    return resolvedClasses as ClassDictionary;\n  };\n};\n\ntype ResolvedMap = {\n  slots: Record<string, string>;\n  modifiers: Record<string, string>;\n  enums: Record<string, Record<string, string>>;\n};\n\n/**\n * Helper to take a css module map and translate it into { slots, modifiers, enums } where\n * slots are a matched name in the slotNames array, enums have underscores splitting the matched\n * name/value, and modifiers are everything else. Creating this split definition keeps runtime\n * resolution work to a minimum.\n */\nfunction createResolvedMap(classes: ClassDictionary): ResolvedMap {\n  const resolvedMap: ResolvedMap = {\n    slots: {},\n    modifiers: {},\n    enums: {},\n  };\n  const { slots, modifiers, enums } = resolvedMap;\n\n  // Iterate through classes\n  Object.keys(classes).forEach((key: string) => {\n    const classValue = classes[key];\n\n    if (classValue) {\n      const classParts = key.split('_');\n\n      // If the class is named the same as a slot, add it to the slot.\n      switch (classParts.length) {\n        case 2: // modifier (_modifierName)\n          modifiers[classParts[1]] = classValue;\n          break;\n\n        case 3: // enum (_enumName_enumValue)\n          const enumName = classParts[1];\n          const enumValue = classParts[2];\n          const enumValues = (enums[enumName] = enums[enumName] || {});\n\n          enumValues[enumValue] = classValue;\n          break;\n\n        default:\n          // slot (root)\n          slots[key] = classValue;\n      }\n    }\n  });\n\n  return resolvedMap;\n}\n"]}