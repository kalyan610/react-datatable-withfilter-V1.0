"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.useCSS = useCSS;

var _serialize = require("@emotion/serialize");

var _classnames = _interopRequireDefault(require("classnames"));

var _stylis = _interopRequireDefault(require("stylis"));

var _stylisPluginFocusVisible = _interopRequireDefault(require("@quid/stylis-plugin-focus-visible"));

var _stylisPluginRtl = _interopRequireDefault(require("stylis-plugin-rtl"));

var _context = require("../context");

// @ts-ignore
// @ts-ignore No typings :(
// @ts-ignore No typings :(
//
// Definitions
//
// SPECIFICITY_CLASSNAME is used to increase the specificity of produced CSS to win over other defined classes.
// "css" used for production to decrease DOM size.
var SPECIFICITY_CLASSNAME = process.env.NODE_ENV === 'production' ? 'css' : 'use-css';
var CLASSNAME_PREFIX = 'f'; // `stylis@3` is a CJS library, there are known issues with them:
// https://github.com/rollup/rollup/issues/1267#issuecomment-446681320

var Stylis = _stylis.default.default || _stylis.default;
var stylisOptions = {
  cascade: true,
  compress: false,
  global: false,
  keyframe: false,
  preserve: false,
  semicolon: false
}; // Two separate instances are requires as we can't call Stylis plugins conditionally

var stylis = new Stylis(stylisOptions);
stylis.use(_stylisPluginFocusVisible.default);
var rtlStylis = new Stylis(stylisOptions);
rtlStylis.use(_stylisPluginFocusVisible.default);
rtlStylis.use(_stylisPluginRtl.default); // Stores a mapping between hashed string and cssified styles object

var stylesCache = {}; //
// Hook
//

function useCSS() {
  var _useFluentContext = (0, _context.useFluentContext)(),
      theme = _useFluentContext.theme,
      renderer = _useFluentContext.renderer,
      rtl = _useFluentContext.rtl;

  for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {
    styles[_key] = arguments[_key];
  }

  if (styles.length === 0) {
    return '';
  } // This resolution allows to map passed classnames to actual styles that can be used on next styles


  var resolvedStyles = styles.reduce(function (acc, style) {
    if (typeof style === 'string') {
      style.split(' ').forEach(function (className) {
        if (stylesCache[className] !== undefined) {
          acc.push(stylesCache[className]);
        }
      });
    } else {
      acc.push(style);
    }

    return acc;
  }, []); // serializeStyles() will concat all passed styles and will resolve functions

  var serializedStyles = (0, _serialize.serializeStyles)(resolvedStyles, stylesCache, theme); // ".name" is not a valid CSS classname as it can start from a digit
  //  "r" prefix is used to avoid collision between LTR and RTL styles

  var serializedClassName = "" + (rtl ? 'r' : '') + CLASSNAME_PREFIX + serializedStyles.name;
  stylesCache[serializedClassName] = serializedStyles.styles; // Selector should include specificity className to have higher specificity than other passed classes

  var selector = "." + SPECIFICITY_CLASSNAME + "." + serializedClassName; // Stylis performs transform of nested selectors and ":focus-visible"

  var css = rtl ? rtlStylis(selector, serializedStyles.styles) : stylis(selector, serializedStyles.styles);
  renderer.renderGlobal(css);
  return (0, _classnames.default)(SPECIFICITY_CLASSNAME, serializedClassName);
}
//# sourceMappingURL=useCSS.js.map
