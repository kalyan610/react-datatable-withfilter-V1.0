"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var styles_1 = require("@fluentui/styles");
var classnames_1 = require("classnames");
var _ = require("lodash");
// this weak map is used as cache for the classes
var classesCache = new WeakMap();
// this weak map is used as cache for the styles
var stylesCache = new WeakMap();
/**
 * Both resolvedStyles and classes are objects of getters with lazy evaluation
 *
 * Additionally if the cacheEnabled option is provided, than the resolved styles
 * and classes are caching the results in WeakMaps. The key of the maps contains the following:
 * - theme
 * - displayName
 * - slot name
 * - styling props
 * - rtl mode
 * - disable animations mode
 */
exports.resolveStyles = function (options, resolvedVariables) {
    var allDisplayNames = options.allDisplayNames, componentClassName = options.className, theme = options.theme, primaryDisplayName = options.primaryDisplayName, componentProps = options.componentProps, inlineStylesProps = options.inlineStylesProps, rtl = options.rtl, disableAnimations = options.disableAnimations, renderer = options.renderer, performanceFlags = options.performance, telemetry = options.telemetry;
    var className = inlineStylesProps.className, design = inlineStylesProps.design, styles = inlineStylesProps.styles, variables = inlineStylesProps.variables;
    var noInlineStylesOverrides = !(design || styles);
    var noVariableOverrides = performanceFlags.enableBooleanVariablesCaching || !variables;
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
        if (!performanceFlags.enableStylesCaching && performanceFlags.enableBooleanVariablesCaching) {
            throw new Error('@fluentui/react-northstar: Please check your "performance" settings on "Provider", to enable "enableBooleanVariablesCaching" you need to enable "enableStylesCaching"');
        }
    }
    if (performanceFlags.enableBooleanVariablesCaching) {
        if (_.isPlainObject(variables)) {
            var hasOnlyBooleanVariables = Object.keys(variables).every(function (variableName) {
                return variables[variableName] === null ||
                    typeof variables[variableName] === 'undefined' ||
                    typeof variables[variableName] === 'boolean';
            });
            if (!hasOnlyBooleanVariables) {
                noVariableOverrides = false;
            }
        }
        else if (!_.isNil(variables)) {
            noVariableOverrides = false;
        }
    }
    var cacheEnabled = performanceFlags.enableStylesCaching && noInlineStylesOverrides && noVariableOverrides;
    // Merge theme styles with inline overrides if any
    var mergedStyles;
    if (allDisplayNames.length === 1) {
        mergedStyles = theme.componentStyles[allDisplayNames[0]] || { root: function () { return ({}); } };
    }
    else {
        var styles_2 = allDisplayNames.map(function (displayName) { return theme.componentStyles[displayName]; }).filter(Boolean);
        if (styles_2.length > 0) {
            mergedStyles = styles_1.mergeComponentStyles.apply(void 0, styles_2);
        }
        else {
            mergedStyles = { root: function () { return ({}); } };
        }
    }
    if (!noInlineStylesOverrides) {
        mergedStyles = styles_1.mergeComponentStyles(mergedStyles, design && styles_1.withDebugId({ root: design }, 'props.design'), styles && styles_1.withDebugId({ root: styles }, 'props.styles'));
    }
    var styleParam = {
        props: componentProps,
        variables: resolvedVariables,
        theme: theme,
        rtl: rtl,
        disableAnimations: disableAnimations,
    };
    // Heads Up! Keep in sync with Design.tsx render logic
    var rendererParam = {
        direction: rtl ? 'rtl' : 'ltr',
        disableAnimations: disableAnimations,
        displayName: allDisplayNames.join(':'),
        sanitizeCss: performanceFlags.enableSanitizeCssPlugin,
    };
    var resolvedStyles = {};
    var resolvedStylesDebug = {};
    var classes = {};
    if (cacheEnabled && theme) {
        if (!stylesCache.has(theme)) {
            stylesCache.set(theme, {});
        }
        if (!classesCache.has(theme)) {
            classesCache.set(theme, {});
        }
    }
    var propsCacheKey = cacheEnabled ? JSON.stringify(componentProps) : '';
    var variablesCacheKey = cacheEnabled && performanceFlags.enableBooleanVariablesCaching ? JSON.stringify(variables) : '';
    var componentCacheKey = cacheEnabled
        ? allDisplayNames.join(':') + ":" + propsCacheKey + ":" + variablesCacheKey + ":" + styleParam.rtl + styleParam.disableAnimations
        : '';
    Object.keys(mergedStyles).forEach(function (slotName) {
        // resolve/render slot styles once and cache
        var lazyEvaluationKey = slotName + "__return";
        var slotCacheKey = componentCacheKey + slotName;
        Object.defineProperty(resolvedStyles, slotName, {
            enumerable: false,
            configurable: false,
            set: function (val) {
                var _a;
                // Add to the cache if it's enabled
                if (cacheEnabled && theme) {
                    stylesCache.set(theme, tslib_1.__assign(tslib_1.__assign({}, stylesCache.get(theme)), (_a = {}, _a[slotCacheKey] = val, _a)));
                }
                resolvedStyles[lazyEvaluationKey] = val;
            },
            get: function () {
                var _a;
                var _b, _c;
                // If caching enabled and entry exists, get from cache, avoid lazy evaluation
                if (cacheEnabled && theme) {
                    var stylesThemeCache = stylesCache.get(theme) || {};
                    if (stylesThemeCache[slotCacheKey]) {
                        return stylesThemeCache[slotCacheKey];
                    }
                }
                if (resolvedStyles[lazyEvaluationKey]) {
                    return resolvedStyles[lazyEvaluationKey];
                }
                var telemetryPartStart = ((_b = telemetry) === null || _b === void 0 ? void 0 : _b.enabled) ? performance.now() : 0;
                // resolve/render slot styles once and cache
                resolvedStyles[lazyEvaluationKey] = mergedStyles[slotName](styleParam);
                if (cacheEnabled && theme) {
                    stylesCache.set(theme, tslib_1.__assign(tslib_1.__assign({}, stylesCache.get(theme)), (_a = {}, _a[slotCacheKey] = resolvedStyles[lazyEvaluationKey], _a)));
                }
                if (process.env.NODE_ENV !== 'production' && styles_1.isDebugEnabled) {
                    resolvedStylesDebug[slotName] = resolvedStyles[slotName]['_debug'];
                    delete resolvedStyles[slotName]['_debug'];
                }
                if (((_c = telemetry) === null || _c === void 0 ? void 0 : _c.enabled) && telemetry.performance[primaryDisplayName]) {
                    telemetry.performance[primaryDisplayName].msResolveStylesTotal += performance.now() - telemetryPartStart;
                }
                return resolvedStyles[lazyEvaluationKey];
            },
        });
        Object.defineProperty(classes, slotName, {
            enumerable: false,
            configurable: false,
            set: function (val) {
                var _a;
                if (cacheEnabled && theme) {
                    classesCache.set(theme, tslib_1.__assign(tslib_1.__assign({}, classesCache.get(theme)), (_a = {}, _a[slotCacheKey] = val, _a)));
                }
                classes[lazyEvaluationKey] = val;
            },
            get: function () {
                var _a;
                var _b, _c, _d;
                if (cacheEnabled && theme) {
                    var classesThemeCache = classesCache.get(theme) || {};
                    //
                    // Cached styles
                    //
                    if (classesThemeCache[slotCacheKey] || classesThemeCache[slotCacheKey] === '') {
                        if ((_b = telemetry) === null || _b === void 0 ? void 0 : _b.performance[primaryDisplayName]) {
                            if (slotName === 'root') {
                                telemetry.performance[primaryDisplayName].stylesRootCacheHits++;
                            }
                            else {
                                telemetry.performance[primaryDisplayName].stylesSlotsCacheHits++;
                            }
                        }
                        return slotName === 'root'
                            ? classnames_1.default(componentClassName, classesThemeCache[slotCacheKey], className)
                            : classesThemeCache[slotCacheKey];
                    }
                }
                //
                // Lazy eval
                //
                if (classes[lazyEvaluationKey]) {
                    return slotName === 'root'
                        ? classnames_1.default(componentClassName, classes[lazyEvaluationKey], className)
                        : classes[lazyEvaluationKey];
                }
                // this resolves the getter magic
                var styleObj = resolvedStyles[slotName];
                var telemetryPartStart = ((_c = telemetry) === null || _c === void 0 ? void 0 : _c.enabled) ? performance.now() : 0;
                if (styleObj) {
                    classes[lazyEvaluationKey] = renderer.renderRule(styleObj, rendererParam);
                    if (cacheEnabled && theme) {
                        classesCache.set(theme, tslib_1.__assign(tslib_1.__assign({}, classesCache.get(theme)), (_a = {}, _a[slotCacheKey] = classes[lazyEvaluationKey], _a)));
                    }
                }
                var resultClassName = slotName === 'root'
                    ? classnames_1.default(componentClassName, classes[lazyEvaluationKey], className)
                    : classes[lazyEvaluationKey];
                if (((_d = telemetry) === null || _d === void 0 ? void 0 : _d.enabled) && telemetry.performance[primaryDisplayName]) {
                    telemetry.performance[primaryDisplayName].msRenderStylesTotal += performance.now() - telemetryPartStart;
                }
                return resultClassName;
            },
        });
    });
    return {
        resolvedStyles: resolvedStyles,
        resolvedStylesDebug: resolvedStylesDebug,
        classes: classes,
    };
};
