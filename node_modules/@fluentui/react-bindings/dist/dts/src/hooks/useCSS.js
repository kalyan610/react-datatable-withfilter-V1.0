"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var serialize_1 = require("@emotion/serialize");
var classnames_1 = require("classnames");
// @ts-ignore
var stylis_1 = require("stylis");
// @ts-ignore No typings :(
var stylis_plugin_focus_visible_1 = require("@quid/stylis-plugin-focus-visible");
// @ts-ignore No typings :(
var stylis_plugin_rtl_1 = require("stylis-plugin-rtl");
var context_1 = require("../context");
//
// Definitions
//
// SPECIFICITY_CLASSNAME is used to increase the specificity of produced CSS to win over other defined classes.
// "css" used for production to decrease DOM size.
var SPECIFICITY_CLASSNAME = process.env.NODE_ENV === 'production' ? 'css' : 'use-css';
var CLASSNAME_PREFIX = 'f';
// `stylis@3` is a CJS library, there are known issues with them:
// https://github.com/rollup/rollup/issues/1267#issuecomment-446681320
var Stylis = stylis_1.default.default || stylis_1.default;
var stylisOptions = {
    cascade: true,
    compress: false,
    global: false,
    keyframe: false,
    preserve: false,
    semicolon: false,
};
// Two separate instances are requires as we can't call Stylis plugins conditionally
var stylis = new Stylis(stylisOptions);
stylis.use(stylis_plugin_focus_visible_1.default);
var rtlStylis = new Stylis(stylisOptions);
rtlStylis.use(stylis_plugin_focus_visible_1.default);
rtlStylis.use(stylis_plugin_rtl_1.default);
// Stores a mapping between hashed string and cssified styles object
var stylesCache = {};
//
// Hook
//
function useCSS() {
    var styles = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        styles[_i] = arguments[_i];
    }
    var _a = context_1.useFluentContext(), theme = _a.theme, renderer = _a.renderer, rtl = _a.rtl;
    if (styles.length === 0) {
        return '';
    }
    // This resolution allows to map passed classnames to actual styles that can be used on next styles
    var resolvedStyles = styles.reduce(function (acc, style) {
        if (typeof style === 'string') {
            style.split(' ').forEach(function (className) {
                if (stylesCache[className] !== undefined) {
                    acc.push(stylesCache[className]);
                }
            });
        }
        else {
            acc.push(style);
        }
        return acc;
    }, []);
    // serializeStyles() will concat all passed styles and will resolve functions
    var serializedStyles = serialize_1.serializeStyles(resolvedStyles, stylesCache, theme);
    // ".name" is not a valid CSS classname as it can start from a digit
    //  "r" prefix is used to avoid collision between LTR and RTL styles
    var serializedClassName = "" + (rtl ? 'r' : '') + CLASSNAME_PREFIX + serializedStyles.name;
    stylesCache[serializedClassName] = serializedStyles.styles;
    // Selector should include specificity className to have higher specificity than other passed classes
    var selector = "." + SPECIFICITY_CLASSNAME + "." + serializedClassName;
    // Stylis performs transform of nested selectors and ":focus-visible"
    var css = rtl ? rtlStylis(selector, serializedStyles.styles) : stylis(selector, serializedStyles.styles);
    renderer.renderGlobal(css);
    return classnames_1.default(SPECIFICITY_CLASSNAME, serializedClassName);
}
exports.useCSS = useCSS;
