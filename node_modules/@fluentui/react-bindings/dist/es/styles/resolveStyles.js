import _isNil from "lodash/isNil";
import _isPlainObject from "lodash/isPlainObject";
import { isDebugEnabled, mergeComponentStyles, withDebugId } from '@fluentui/styles';
import cx from 'classnames';
// this weak map is used as cache for the classes
var classesCache = new WeakMap(); // this weak map is used as cache for the styles

var stylesCache = new WeakMap();
/**
 * Both resolvedStyles and classes are objects of getters with lazy evaluation
 *
 * Additionally if the cacheEnabled option is provided, than the resolved styles
 * and classes are caching the results in WeakMaps. The key of the maps contains the following:
 * - theme
 * - displayName
 * - slot name
 * - styling props
 * - rtl mode
 * - disable animations mode
 */

export var resolveStyles = function resolveStyles(options, resolvedVariables) {
  var allDisplayNames = options.allDisplayNames,
      componentClassName = options.className,
      theme = options.theme,
      primaryDisplayName = options.primaryDisplayName,
      componentProps = options.componentProps,
      inlineStylesProps = options.inlineStylesProps,
      rtl = options.rtl,
      disableAnimations = options.disableAnimations,
      renderer = options.renderer,
      performanceFlags = options.performance,
      telemetry = options.telemetry;
  var className = inlineStylesProps.className,
      design = inlineStylesProps.design,
      styles = inlineStylesProps.styles,
      variables = inlineStylesProps.variables;
  var noInlineStylesOverrides = !(design || styles);
  var noVariableOverrides = performanceFlags.enableBooleanVariablesCaching || !variables;
  /* istanbul ignore else */

  if (process.env.NODE_ENV !== 'production') {
    if (!performanceFlags.enableStylesCaching && performanceFlags.enableBooleanVariablesCaching) {
      throw new Error('@fluentui/react-northstar: Please check your "performance" settings on "Provider", to enable "enableBooleanVariablesCaching" you need to enable "enableStylesCaching"');
    }
  }

  if (performanceFlags.enableBooleanVariablesCaching) {
    if (_isPlainObject(variables)) {
      var hasOnlyBooleanVariables = Object.keys(variables).every(function (variableName) {
        return variables[variableName] === null || typeof variables[variableName] === 'undefined' || typeof variables[variableName] === 'boolean';
      });

      if (!hasOnlyBooleanVariables) {
        noVariableOverrides = false;
      }
    } else if (!_isNil(variables)) {
      noVariableOverrides = false;
    }
  }

  var cacheEnabled = performanceFlags.enableStylesCaching && noInlineStylesOverrides && noVariableOverrides; // Merge theme styles with inline overrides if any

  var mergedStyles;

  if (allDisplayNames.length === 1) {
    mergedStyles = theme.componentStyles[allDisplayNames[0]] || {
      root: function root() {
        return {};
      }
    };
  } else {
    var _styles = allDisplayNames.map(function (displayName) {
      return theme.componentStyles[displayName];
    }).filter(Boolean);

    if (_styles.length > 0) {
      mergedStyles = mergeComponentStyles.apply(void 0, _styles);
    } else {
      mergedStyles = {
        root: function root() {
          return {};
        }
      };
    }
  }

  if (!noInlineStylesOverrides) {
    mergedStyles = mergeComponentStyles(mergedStyles, design && withDebugId({
      root: design
    }, 'props.design'), styles && withDebugId({
      root: styles
    }, 'props.styles'));
  }

  var styleParam = {
    props: componentProps,
    variables: resolvedVariables,
    theme: theme,
    rtl: rtl,
    disableAnimations: disableAnimations
  }; // Heads Up! Keep in sync with Design.tsx render logic

  var rendererParam = {
    direction: rtl ? 'rtl' : 'ltr',
    disableAnimations: disableAnimations,
    displayName: allDisplayNames.join(':'),
    // does not affect styles, only used by useEnhancedRenderer in docs
    sanitizeCss: performanceFlags.enableSanitizeCssPlugin
  };
  var resolvedStyles = {};
  var resolvedStylesDebug = {};
  var classes = {};

  if (cacheEnabled && theme) {
    if (!stylesCache.has(theme)) {
      stylesCache.set(theme, {});
    }

    if (!classesCache.has(theme)) {
      classesCache.set(theme, {});
    }
  }

  var propsCacheKey = cacheEnabled ? JSON.stringify(componentProps) : '';
  var variablesCacheKey = cacheEnabled && performanceFlags.enableBooleanVariablesCaching ? JSON.stringify(variables) : '';
  var componentCacheKey = cacheEnabled ? allDisplayNames.join(':') + ":" + propsCacheKey + ":" + variablesCacheKey + ":" + styleParam.rtl + styleParam.disableAnimations : '';
  Object.keys(mergedStyles).forEach(function (slotName) {
    // resolve/render slot styles once and cache
    var lazyEvaluationKey = slotName + "__return";
    var slotCacheKey = componentCacheKey + slotName;
    Object.defineProperty(resolvedStyles, slotName, {
      enumerable: false,
      configurable: false,
      set: function set(val) {
        // Add to the cache if it's enabled
        if (cacheEnabled && theme) {
          var _Object$assign;

          stylesCache.set(theme, Object.assign({}, stylesCache.get(theme), (_Object$assign = {}, _Object$assign[slotCacheKey] = val, _Object$assign)));
        }

        resolvedStyles[lazyEvaluationKey] = val;
      },
      get: function get() {
        // If caching enabled and entry exists, get from cache, avoid lazy evaluation
        if (cacheEnabled && theme) {
          var stylesThemeCache = stylesCache.get(theme) || {};

          if (stylesThemeCache[slotCacheKey]) {
            return stylesThemeCache[slotCacheKey];
          }
        }

        if (resolvedStyles[lazyEvaluationKey]) {
          return resolvedStyles[lazyEvaluationKey];
        }

        var telemetryPartStart = (telemetry == null ? void 0 : telemetry.enabled) ? performance.now() : 0; // resolve/render slot styles once and cache

        resolvedStyles[lazyEvaluationKey] = mergedStyles[slotName](styleParam);

        if (cacheEnabled && theme) {
          var _Object$assign2;

          stylesCache.set(theme, Object.assign({}, stylesCache.get(theme), (_Object$assign2 = {}, _Object$assign2[slotCacheKey] = resolvedStyles[lazyEvaluationKey], _Object$assign2)));
        }

        if (process.env.NODE_ENV !== 'production' && isDebugEnabled) {
          resolvedStylesDebug[slotName] = resolvedStyles[slotName]['_debug'];
          delete resolvedStyles[slotName]['_debug'];
        }

        if ((telemetry == null ? void 0 : telemetry.enabled) && telemetry.performance[primaryDisplayName]) {
          telemetry.performance[primaryDisplayName].msResolveStylesTotal += performance.now() - telemetryPartStart;
        }

        return resolvedStyles[lazyEvaluationKey];
      }
    });
    Object.defineProperty(classes, slotName, {
      enumerable: false,
      configurable: false,
      set: function set(val) {
        if (cacheEnabled && theme) {
          var _Object$assign3;

          classesCache.set(theme, Object.assign({}, classesCache.get(theme), (_Object$assign3 = {}, _Object$assign3[slotCacheKey] = val, _Object$assign3)));
        }

        classes[lazyEvaluationKey] = val;
      },
      get: function get() {
        if (cacheEnabled && theme) {
          var classesThemeCache = classesCache.get(theme) || {}; //
          // Cached styles
          //

          if (classesThemeCache[slotCacheKey] || classesThemeCache[slotCacheKey] === '') {
            if (telemetry == null ? void 0 : telemetry.performance[primaryDisplayName]) {
              if (slotName === 'root') {
                telemetry.performance[primaryDisplayName].stylesRootCacheHits++;
              } else {
                telemetry.performance[primaryDisplayName].stylesSlotsCacheHits++;
              }
            }

            return slotName === 'root' ? cx(componentClassName, classesThemeCache[slotCacheKey], className) : classesThemeCache[slotCacheKey];
          }
        } //
        // Lazy eval
        //


        if (classes[lazyEvaluationKey]) {
          return slotName === 'root' ? cx(componentClassName, classes[lazyEvaluationKey], className) : classes[lazyEvaluationKey];
        } // this resolves the getter magic


        var styleObj = resolvedStyles[slotName];
        var telemetryPartStart = (telemetry == null ? void 0 : telemetry.enabled) ? performance.now() : 0;

        if (styleObj) {
          classes[lazyEvaluationKey] = renderer.renderRule(styleObj, rendererParam);

          if (cacheEnabled && theme) {
            var _Object$assign4;

            classesCache.set(theme, Object.assign({}, classesCache.get(theme), (_Object$assign4 = {}, _Object$assign4[slotCacheKey] = classes[lazyEvaluationKey], _Object$assign4)));
          }
        }

        var resultClassName = slotName === 'root' ? cx(componentClassName, classes[lazyEvaluationKey], className) : classes[lazyEvaluationKey];

        if ((telemetry == null ? void 0 : telemetry.enabled) && telemetry.performance[primaryDisplayName]) {
          telemetry.performance[primaryDisplayName].msRenderStylesTotal += performance.now() - telemetryPartStart;
        }

        return resultClassName;
      }
    });
  });
  return {
    resolvedStyles: resolvedStyles,
    resolvedStylesDebug: resolvedStylesDebug,
    classes: classes
  };
};
//# sourceMappingURL=resolveStyles.js.map
