import { __awaiter, __generator } from "tslib";
import { addProp, TextParser, headers, body } from "@pnp/odata";
import { _List, List } from "../lists/types";
import { Folder } from "../folders/types";
import { combine, isArray } from "@pnp/common";
import { escapeQueryStrValue } from "../utils/escapeQueryStrValue";
import { Logger } from "@pnp/logging";
import { spPost } from "../operations";
import { SharePointQueryableCollection } from "../presets/all";
addProp(_List, "rootFolder", Folder, "rootFolder");
_List.prototype.getDefaultColumnValues = function () {
    return __awaiter(this, void 0, void 0, function () {
        var pathPart, webUrl, path, baseFilePath, xml, e_1, matches, tags;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, this.rootFolder.select("ServerRelativePath")()];
                case 1:
                    pathPart = _a.sent();
                    return [4 /*yield*/, this.select("ParentWeb/Url").expand("ParentWeb")()];
                case 2:
                    webUrl = _a.sent();
                    path = combine("/", pathPart.ServerRelativePath.DecodedUrl, "Forms/client_LocationBasedDefaults.html");
                    baseFilePath = combine(webUrl.ParentWeb.Url, "_api/web", "getFileByServerRelativePath(decodedUrl='" + escapeQueryStrValue(path) + "')");
                    xml = "";
                    _a.label = 3;
                case 3:
                    _a.trys.push([3, 5, , 6]);
                    return [4 /*yield*/, Folder(baseFilePath, "$value").usingParser(new TextParser())(headers({ "binaryStringResponseBody": "true" }))];
                case 4:
                    xml = _a.sent();
                    return [3 /*break*/, 6];
                case 5:
                    e_1 = _a.sent();
                    // if this call fails we assume it is because the file is 404
                    if (e_1 && e_1.status && e_1.status === 404) {
                        // return an empty array
                        return [2 /*return*/, []];
                    }
                    throw e_1;
                case 6:
                    matches = xml.match(/<a.*?<\/a>/ig);
                    tags = matches === null ? [] : matches.map(function (t) { return t.trim(); });
                    // now we need to turn these tags of form into objects
                    // <a href="/sites/dev/My%20Title"><DefaultValue FieldName="TextField">Test</DefaultValue></a>
                    return [2 /*return*/, tags.map(function (t) {
                            var m = /<a href="(.*?)"><DefaultValue FieldName="(.*?)">(.*?)<\/DefaultValue>/ig.exec(t);
                            // if things worked our captures are:
                            // 0: whole string
                            // 1: ENCODED server relative path
                            // 2: Field internal name
                            // 3: Default value as string
                            if (m.length < 1) {
                                // this indicates an error somewhere, but we have no way to meaningfully recover
                                // perhaps the way the tags are stored has changed on the server? Check that first.
                                Logger.write("Could not parse default column value from '" + t + "'", 2 /* Warning */);
                                return null;
                            }
                            // return the parsed out values
                            return {
                                name: m[2],
                                path: decodeURIComponent(m[1]),
                                value: m[3],
                            };
                        }).filter(function (v) { return v !== null; })];
            }
        });
    });
};
_List.prototype.setDefaultColumnValues = function (defaults) {
    return __awaiter(this, void 0, void 0, function () {
        var fieldDefs, tags, xml, pathPart, webUrl, path, baseFilePath, existingReceivers;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, SharePointQueryableCollection(this, "fields").select("InternalName", "TypeAsString").filter("Hidden ne true")()];
                case 1:
                    fieldDefs = _a.sent();
                    tags = defaults.map(function (fieldDefault) {
                        var index = fieldDefs.findIndex(function (fd) { return fd.InternalName === fieldDefault.name; });
                        if (index < 0) {
                            throw Error("Field '" + fieldDefault.name + "' does not exist in the list. Please check the internal field name. Failed to set defaults.");
                        }
                        var fieldDef = fieldDefs[index];
                        var value = "";
                        switch (fieldDef.TypeAsString) {
                            case "Boolean":
                            case "Currency":
                            case "Text":
                            case "DateTime":
                            case "Number":
                            case "Choice":
                            case "User":
                                if (isArray(fieldDefault.value)) {
                                    throw Error("The type '" + fieldDef.TypeAsString + "' does not support multiple values.");
                                }
                                value = "" + fieldDefault.value;
                                break;
                            case "MultiChoice":
                                if (isArray(fieldDefault.value)) {
                                    value = fieldDefault.value.map(function (v) { return "" + v; }).join(";");
                                }
                                else {
                                    value = "" + fieldDefault.value;
                                }
                                break;
                            case "UserMulti":
                                if (isArray(fieldDefault.value)) {
                                    value = fieldDefault.value.map(function (v) { return "" + v; }).join(";#");
                                }
                                else {
                                    value = "" + fieldDefault.value;
                                }
                                break;
                            case "Taxonomy":
                                if (isArray(fieldDefault.value)) {
                                    throw Error("The type '" + fieldDef.TypeAsString + "' does not support multiple values.");
                                }
                                else {
                                    value = fieldDefault.value.wssId + ";#" + fieldDefault.value.termName + "|" + fieldDefault.value.termId;
                                }
                                break;
                            case "TaxonomyMulti":
                                if (isArray(fieldDefault.value)) {
                                    value = fieldDefault.value.map(function (v) { return v.wssId + ";#" + v.termName + "|" + v.termId; }).join(";#");
                                }
                                value = fieldDefault.value.wssId + ";#" + fieldDefault.value.termName + "|" + fieldDefault.value.termId;
                                break;
                        }
                        return "<a href=\"" + fieldDefault.path.replace(/ /gi, "%20") + "\"><DefaultValue FieldName=\"" + fieldDefault.name + "\">" + value + "</DefaultValue></a>";
                    });
                    xml = "<MetadataDefaults>" + tags.join("") + "</MetadataDefaults>";
                    return [4 /*yield*/, this.rootFolder.select("ServerRelativePath")()];
                case 2:
                    pathPart = _a.sent();
                    return [4 /*yield*/, this.select("ParentWeb/Url").expand("ParentWeb")()];
                case 3:
                    webUrl = _a.sent();
                    path = combine("/", pathPart.ServerRelativePath.DecodedUrl, "Forms");
                    baseFilePath = combine(webUrl.ParentWeb.Url, "_api/web", "getFolderByServerRelativePath(decodedUrl='" + escapeQueryStrValue(path) + "')", "files");
                    return [4 /*yield*/, spPost(Folder(baseFilePath, "add(overwrite=true,url='client_LocationBasedDefaults.html')"), { body: xml })];
                case 4:
                    _a.sent();
                    return [4 /*yield*/, this.eventReceivers.filter("ReceiverName eq 'LocationBasedMetadataDefaultsReceiver ItemAdded'").select("ReceiverId")()];
                case 5:
                    existingReceivers = _a.sent();
                    if (!(existingReceivers.length < 1)) return [3 /*break*/, 7];
                    return [4 /*yield*/, spPost(List(this.eventReceivers, "add"), body({
                            eventReceiverCreationInformation: {
                                EventType: 10001,
                                ReceiverAssembly: "Microsoft.Office.DocumentManagement, Version=16.0.0.0, Culture=neutral, PublicKeyToken=71e9bce111e9429c",
                                ReceiverClass: "Microsoft.Office.DocumentManagement.LocationBasedMetadataDefaultsReceiver",
                                ReceiverName: "LocationBasedMetadataDefaultsReceiver ItemAdded",
                                SequenceNumber: 1000,
                                Synchronization: 1,
                            },
                        }))];
                case 6:
                    _a.sent();
                    _a.label = 7;
                case 7: return [2 /*return*/];
            }
        });
    });
};
//# sourceMappingURL=list.js.map