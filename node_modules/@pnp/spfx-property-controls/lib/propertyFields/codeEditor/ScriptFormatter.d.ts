/**
 * Helper class to format the JavaScript code.
 * Based on code initially developed by: http://jsbeautifier.org/
 *
 * Usage:
    js_beautify(js_source_text);
    js_beautify(js_source_text, options);

  The options are:
    indent_size (default 4)          - indentation size,
    indent_char (default space)      - character to indent with,
    preserve_newlines (default true) - whether existing line breaks should be preserved,
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

            jslint_happy   !jslint_happy
            ---------------------------------
             function ()      function()

    brace_style (default "collapse") - "collapse" | "expand" | "end-expand"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.

    space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
                be preserved if it were present.

    e.g

    js_beautify(js_source_text, {
      'indent_size': 1,
      'indent_char': '\t'
    });
 */
export declare class ScriptFormatter {
    private nonASCIIwhitespace;
    private nonASCIIidentifierStartChars;
    private nonASCIIidentifierChars;
    private nonASCIIidentifierStart;
    private nonASCIIidentifier;
    private input;
    private output_lines;
    private token_text;
    private token_type;
    private last_type;
    private last_last_text;
    private indent_string;
    private flags;
    private previous_flags;
    private flag_store;
    private whitespace;
    private wordchar;
    private punct;
    private parser_pos;
    private line_starters;
    private reserved_words;
    private digits;
    private prefix;
    private input_wanted_newline;
    private output_wrapped;
    private output_space_before_token;
    private input_length;
    private n_newlines;
    private whitespace_before_token;
    private opt;
    private preindent_string;
    private MODE;
    private handlers;
    private newline;
    private lineBreak;
    private isIdentifierStart;
    private isIdentifierChar;
    private create_flags;
    private create_output_line;
    private trim_output;
    private trim_output_line;
    private trim;
    private split_newlines;
    private just_added_newline;
    private just_added_blankline;
    private allow_wrap_or_preserved_newline;
    private print_newline;
    private print_token_line_indentation;
    private print_indent_string;
    private print_token_space_before;
    private print_token;
    private indent;
    private deindent;
    private remove_redundant_indentation;
    private set_mode;
    private is_array;
    private is_expression;
    private restore_mode;
    private start_of_object_property;
    private start_of_statement;
    private all_lines_start_with;
    private is_special_word;
    private in_array;
    private unescape_string;
    private is_next;
    private get_next_token;
    private handle_start_expr;
    private handle_end_expr;
    private handle_start_block;
    private handle_end_block;
    private handle_word;
    private handle_semicolon;
    private handle_string;
    private handle_equals;
    private handle_comma;
    private handle_operator;
    private handle_block_comment;
    private handle_inline_comment;
    private handle_comment;
    private handle_dot;
    private handle_unknown;
    private beautify;
    js_beautify(js_source_text: string, options: any): string;
}
//# sourceMappingURL=ScriptFormatter.d.ts.map