import { __awaiter, __decorate } from "tslib";
import { SharePointQueryable, _SharePointQueryableInstance, _SharePointQueryableCollection, SharePointQueryableInstance, spInvokableFactory, deleteableWithETag, } from "../sharepointqueryable.js";
import { assign, hOP } from "@pnp/common";
import { List } from "../lists/types.js";
import { ODataParser, body, headers } from "@pnp/odata";
import { Logger } from "@pnp/logging";
import { metadata } from "../utils/metadata.js";
import { defaultPath } from "../decorators.js";
import { spPost } from "../operations.js";
import { tag } from "../telemetry.js";
/**
 * Describes a collection of Item objects
 *
 */
let _Items = class _Items extends _SharePointQueryableCollection {
    /**
    * Gets an Item by id
    *
    * @param id The integer id of the item to retrieve
    */
    getById(id) {
        return tag.configure(Item(this).concat(`(${id})`), "is.getById");
    }
    /**
     * Gets BCS Item by string id
     *
     * @param stringId The string id of the BCS item to retrieve
     */
    getItemByStringId(stringId) {
        // creates an item with the parent list path and append out method call
        return tag.configure(Item(this.parentUrl, `getItemByStringId('${stringId}')`), "is.getItemByStringId");
    }
    /**
     * Skips the specified number of items (https://msdn.microsoft.com/en-us/library/office/fp142385.aspx#sectionSection6)
     *
     * @param skip The starting id where the page should start, use with top to specify pages
     * @param reverse It true the PagedPrev=true parameter is added allowing backwards navigation in the collection
     */
    skip(skip, reverse = false) {
        if (reverse) {
            this.query.set("$skiptoken", encodeURIComponent(`Paged=TRUE&PagedPrev=TRUE&p_ID=${skip}`));
        }
        else {
            this.query.set("$skiptoken", encodeURIComponent(`Paged=TRUE&p_ID=${skip}`));
        }
        return this;
    }
    /**
     * Gets a collection designed to aid in paging through data
     *
     */
    getPaged() {
        return this.usingParser(new PagedItemCollectionParser(this))();
    }
    /**
     * Gets all the items in a list, regardless of count. Does not support batching or caching
     *
     *  @param requestSize Number of items to return in each request (Default: 2000)
     *  @param acceptHeader Allows for setting the value of the Accept header for SP 2013 support
     */
    getAll(requestSize = 2000, acceptHeader = "application/json;odata=nometadata") {
        Logger.write("Calling items.getAll should be done sparingly. Ensure this is the correct choice. If you are unsure, it is not.", 2 /* Warning */);
        // this will be used for the actual query
        // and we set no metadata here to try and reduce traffic
        const items = Items(this, "").top(requestSize).configure({
            headers: {
                "Accept": acceptHeader,
            },
        });
        // let's copy over the odata query params that can be applied
        // $top - allow setting the page size this way (override what we did above)
        // $select - allow picking the return fields (good behavior)
        // $filter - allow setting a filter, though this may fail due for large lists
        this.query.forEach((v, k) => {
            if (/^\$select|filter|top|expand$/i.test(k)) {
                items.query.set(k, v);
            }
        });
        // give back the promise
        return new Promise((resolve, reject) => {
            // this will eventually hold the items we return
            const itemsCollector = [];
            // action that will gather up our results recursively
            const gatherer = (last) => {
                // collect that set of results
                [].push.apply(itemsCollector, last.results);
                // if we have more, repeat - otherwise resolve with the collected items
                if (last.hasNext) {
                    last.getNext().then(gatherer).catch(reject);
                }
                else {
                    resolve(itemsCollector);
                }
            };
            // start the cycle
            items.getPaged().then(gatherer).catch(reject);
        });
    }
    /**
     * Adds a new item to the collection
     *
     * @param properties The new items's properties
     * @param listItemEntityTypeFullName The type name of the list's entities
     */
    add(properties = {}, listItemEntityTypeFullName = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const removeDependency = this.addBatchDependency();
            const listItemEntityType = yield this.ensureListItemEntityTypeName(listItemEntityTypeFullName);
            const postBody = body(assign(metadata(listItemEntityType), properties));
            const promise = spPost(this.clone(Items, ""), postBody).then((data) => {
                return {
                    data: data,
                    item: this.getById(data.Id),
                };
            });
            removeDependency();
            return promise;
        });
    }
    /**
     * Ensures we have the proper list item entity type name, either from the value provided or from the list
     *
     * @param candidatelistItemEntityTypeFullName The potential type name
     */
    ensureListItemEntityTypeName(candidatelistItemEntityTypeFullName) {
        return __awaiter(this, void 0, void 0, function* () {
            return candidatelistItemEntityTypeFullName ?
                candidatelistItemEntityTypeFullName :
                this.getParent(List).getListItemEntityTypeFullName();
        });
    }
};
__decorate([
    tag("is.getPaged")
], _Items.prototype, "getPaged", null);
__decorate([
    tag("is.getAll")
], _Items.prototype, "getAll", null);
__decorate([
    tag("is.add")
], _Items.prototype, "add", null);
_Items = __decorate([
    defaultPath("items")
], _Items);
export { _Items };
export const Items = spInvokableFactory(_Items);
/**
 * Descrines a single Item instance
 *
 */
export class _Item extends _SharePointQueryableInstance {
    constructor() {
        super(...arguments);
        this.delete = deleteableWithETag("i");
    }
    /**
     * Gets the effective base permissions for the item
     *
     */
    get effectiveBasePermissions() {
        return tag.configure(SharePointQueryable(this, "EffectiveBasePermissions"), "i.effectiveBasePermissions");
    }
    /**
     * Gets the effective base permissions for the item in a UI context
     *
     */
    get effectiveBasePermissionsForUI() {
        return tag.configure(SharePointQueryable(this, "EffectiveBasePermissionsForUI"), "i.effectiveBasePermissionsForUI");
    }
    /**
     * Gets the field values for this list item in their HTML representation
     *
     */
    get fieldValuesAsHTML() {
        return tag.configure(SharePointQueryableInstance(this, "FieldValuesAsHTML"), "i.fvHTML");
    }
    /**
     * Gets the field values for this list item in their text representation
     *
     */
    get fieldValuesAsText() {
        return tag.configure(SharePointQueryableInstance(this, "FieldValuesAsText"), "i.fvText");
    }
    /**
     * Gets the field values for this list item for use in editing controls
     *
     */
    get fieldValuesForEdit() {
        return tag.configure(SharePointQueryableInstance(this, "FieldValuesForEdit"), "i.fvEdit");
    }
    /**
     * Gets the collection of versions associated with this item
     */
    get versions() {
        return tag.configure(ItemVersions(this), "i.versions");
    }
    get list() {
        return this.getParent(List, this.parentUrl.substr(0, this.parentUrl.lastIndexOf("/")));
    }
    /**
     * Updates this list instance with the supplied properties
     *
     * @param properties A plain object hash of values to update for the list
     * @param eTag Value used in the IF-Match header, by default "*"
     * @param listItemEntityTypeFullName The type name of the list's entities
     */
    update(properties, eTag = "*", listItemEntityTypeFullName = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const removeDependency = this.addBatchDependency();
            const listItemEntityType = yield this.ensureListItemEntityTypeName(listItemEntityTypeFullName);
            const postBody = body(assign(metadata(listItemEntityType), properties), headers({
                "IF-Match": eTag,
                "X-HTTP-Method": "MERGE",
            }));
            removeDependency();
            const poster = tag.configure(this.clone(Item).usingParser(new ItemUpdatedParser()), "i.update");
            const data = yield spPost(poster, postBody);
            return {
                data,
                item: this,
            };
        });
    }
    /**
     * Moves the list item to the Recycle Bin and returns the identifier of the new Recycle Bin item.
     */
    recycle() {
        return spPost(this.clone(Item, "recycle"));
    }
    /**
     * Deletes the item object with options.
     *
     * @param parameters Specifies the options to use when deleting a item.
     */
    deleteWithParams(parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            return spPost(this.clone(Item, "DeleteWithParameters"), body({ parameters }));
        });
    }
    /**
     * Gets a string representation of the full URL to the WOPI frame.
     * If there is no associated WOPI application, or no associated action, an empty string is returned.
     *
     * @param action Display mode: 0: view, 1: edit, 2: mobileView, 3: interactivePreview
     */
    getWopiFrameUrl(action = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const i = this.clone(Item, "getWOPIFrameUrl(@action)");
            i.query.set("@action", action);
            const data = yield spPost(i);
            // handle verbose mode
            if (hOP(data, "GetWOPIFrameUrl")) {
                return data.GetWOPIFrameUrl;
            }
            return data;
        });
    }
    /**
     * Validates and sets the values of the specified collection of fields for the list item.
     *
     * @param formValues The fields to change and their new values.
     * @param bNewDocumentUpdate true if the list item is a document being updated after upload; otherwise false.
     */
    validateUpdateListItem(formValues, bNewDocumentUpdate = false) {
        return spPost(this.clone(Item, "validateupdatelistitem"), body({ formValues, bNewDocumentUpdate }));
    }
    /**
     * Gets the parent information for this item's list and web
     */
    getParentInfos() {
        return __awaiter(this, void 0, void 0, function* () {
            const urlInfo = yield this.select("Id", "ParentList/Id", "ParentList/RootFolder/UniqueId", "ParentList/RootFolder/ServerRelativeUrl", "ParentList/RootFolder/ServerRelativePath", "ParentList/ParentWeb/Id", "ParentList/ParentWeb/Url", "ParentList/ParentWeb/ServerRelativeUrl", "ParentList/ParentWeb/ServerRelativePath").expand("ParentList", "ParentList/RootFolder", "ParentList/ParentWeb")();
            return {
                Item: {
                    Id: urlInfo.Id,
                },
                ParentList: {
                    Id: urlInfo.ParentList.Id,
                    RootFolderServerRelativePath: urlInfo.ParentList.RootFolder.ServerRelativePath,
                    RootFolderServerRelativeUrl: urlInfo.ParentList.RootFolder.ServerRelativeUrl,
                    RootFolderUniqueId: urlInfo.ParentList.RootFolder.UniqueId,
                },
                ParentWeb: {
                    Id: urlInfo.ParentList.ParentWeb.Id,
                    ServerRelativePath: urlInfo.ParentList.ParentWeb.ServerRelativePath,
                    ServerRelativeUrl: urlInfo.ParentList.ParentWeb.ServerRelativeUrl,
                    Url: urlInfo.ParentList.ParentWeb.Url,
                },
            };
        });
    }
    /**
     * Ensures we have the proper list item entity type name, either from the value provided or from the list
     *
     * @param candidatelistItemEntityTypeFullName The potential type name
     */
    ensureListItemEntityTypeName(candidatelistItemEntityTypeFullName) {
        return __awaiter(this, void 0, void 0, function* () {
            return candidatelistItemEntityTypeFullName ?
                candidatelistItemEntityTypeFullName :
                this.list.getListItemEntityTypeFullName();
        });
    }
}
__decorate([
    tag("i.recycle")
], _Item.prototype, "recycle", null);
__decorate([
    tag("i.del-params")
], _Item.prototype, "deleteWithParams", null);
__decorate([
    tag("i.getWopiFrameUrl")
], _Item.prototype, "getWopiFrameUrl", null);
__decorate([
    tag("i.validateUpdateListItem")
], _Item.prototype, "validateUpdateListItem", null);
export const Item = spInvokableFactory(_Item);
/**
 * Describes a collection of Version objects
 *
 */
let _ItemVersions = class _ItemVersions extends _SharePointQueryableCollection {
    /**
     * Gets a version by id
     *
     * @param versionId The id of the version to retrieve
     */
    getById(versionId) {
        return tag.configure(ItemVersion(this).concat(`(${versionId})`), "iv.getById");
    }
};
_ItemVersions = __decorate([
    defaultPath("versions")
], _ItemVersions);
export { _ItemVersions };
export const ItemVersions = spInvokableFactory(_ItemVersions);
/**
 * Describes a single Version instance
 *
 */
export class _ItemVersion extends _SharePointQueryableInstance {
    constructor() {
        super(...arguments);
        this.delete = deleteableWithETag("iv");
    }
}
export const ItemVersion = spInvokableFactory(_ItemVersion);
/**
 * Provides paging functionality for list items
 */
export class PagedItemCollection {
    constructor(parent, nextUrl, results) {
        this.parent = parent;
        this.nextUrl = nextUrl;
        this.results = results;
    }
    /**
     * If true there are more results available in the set, otherwise there are not
     */
    get hasNext() {
        return typeof this.nextUrl === "string" && this.nextUrl.length > 0;
    }
    /**
     * Gets the next set of results, or resolves to null if no results are available
     */
    getNext() {
        if (this.hasNext) {
            const items = tag.configure(Items(this.nextUrl, null).configureFrom(this.parent), "ip.getNext");
            return items.getPaged();
        }
        return new Promise(r => r(null));
    }
}
class PagedItemCollectionParser extends ODataParser {
    constructor(_parent) {
        super();
        this._parent = _parent;
    }
    parse(r) {
        return new Promise((resolve, reject) => {
            if (this.handleError(r, reject)) {
                r.json().then(json => {
                    const nextUrl = hOP(json, "d") && hOP(json.d, "__next") ? json.d.__next : json["odata.nextLink"];
                    resolve(new PagedItemCollection(this._parent, nextUrl, this.parseODataJSON(json)));
                });
            }
        });
    }
}
class ItemUpdatedParser extends ODataParser {
    parse(r) {
        return new Promise((resolve, reject) => {
            if (this.handleError(r, reject)) {
                resolve({
                    "odata.etag": r.headers.get("etag"),
                });
            }
        });
    }
}
//# sourceMappingURL=types.js.map