import { __awaiter, __decorate } from "tslib";
import { defaultPath } from "../decorators.js";
import { _SharePointQueryableCollection, spInvokableFactory, _SharePointQueryableInstance } from "../sharepointqueryable.js";
import { tag } from "../telemetry.js";
/**
 * Describes a collection of Form objects
 *
 */
let _TermStore = class _TermStore extends _SharePointQueryableInstance {
    /**
     * Gets the term groups associated with this tenant
     */
    get groups() {
        return tag.configure(TermGroups(this), "txts.groups");
    }
    /**
     * Gets the term groups associated with this tenant
     */
    get sets() {
        return tag.configure(TermSets(this), "txts.sets");
    }
};
_TermStore = __decorate([
    defaultPath("_api/v2.1/termstore")
], _TermStore);
export { _TermStore };
export const TermStore = spInvokableFactory(_TermStore);
let _TermGroups = class _TermGroups extends _SharePointQueryableCollection {
    /**
     * Gets a term group by id
     *
     * @param id Id of the term group to access
     */
    getById(id) {
        return tag.configure(TermGroup(this, id), "txtgs.getById");
    }
};
_TermGroups = __decorate([
    defaultPath("groups")
], _TermGroups);
export { _TermGroups };
export const TermGroups = spInvokableFactory(_TermGroups);
export class _TermGroup extends _SharePointQueryableInstance {
    /**
     * Gets the term sets associated with this tenant
     */
    get sets() {
        return tag.configure(TermSets(this, "sets"), "txtg.sets");
    }
}
export const TermGroup = spInvokableFactory(_TermGroup);
let _TermSets = class _TermSets extends _SharePointQueryableCollection {
    /**
     * Gets a term group by id
     *
     * @param id Id of the term group to access
     */
    getById(id) {
        return tag.configure(TermSet(this, id), "txts.getById");
    }
};
_TermSets = __decorate([
    defaultPath("sets")
], _TermSets);
export { _TermSets };
export const TermSets = spInvokableFactory(_TermSets);
export class _TermSet extends _SharePointQueryableInstance {
    /**
     * Gets all the terms in this set
     */
    get terms() {
        return Terms(this);
    }
    get parentGroup() {
        return tag.configure(TermGroup(this, "parentGroup"), "txts.parentGroup");
    }
    get children() {
        return tag.configure(Children(this), "txts.children");
    }
    get relations() {
        return tag.configure(Relations(this), "txts.relations");
    }
    getTermById(id) {
        return tag.configure(this.clone(Term, `terms/${id}`), "txts.getTermById");
    }
    /**
     * Gets all the terms in this termset in an ordered tree using the appropriate sort ordering
     * ** This is an expensive operation and you should strongly consider caching the results **
     */
    getAllChildrenAsOrderedTree() {
        return __awaiter(this, void 0, void 0, function* () {
            const setInfo = yield this.select("*", "customSortOrder")();
            const tree = [];
            const ensureOrder = (terms, sorts, setSorts) => {
                // handle custom sort order
                let ordering = null;
                if (sorts === null && setSorts.length > 0) {
                    ordering = [...setSorts];
                }
                else {
                    const index = sorts.findIndex(v => v.setId === setInfo.id);
                    if (index >= 0) {
                        ordering = [...sorts[index].order];
                    }
                }
                if (ordering !== null) {
                    const orderedChildren = [];
                    ordering.forEach(o => {
                        const found = terms.find(ch => o === ch.id);
                        if (found) {
                            orderedChildren.push(found);
                        }
                    });
                    // we have a case where if a set is ordered and a term is added to that set
                    // AND the ordering information hasn't been updated the new term will not have
                    // any associated ordering information. See #1547 which reported this. So here we
                    // append any terms remaining in "terms" not in "orderedChildren" to the end of "orderedChildren"
                    orderedChildren.push(...terms.filter(info => ordering.indexOf(info.id) < 0));
                    return orderedChildren;
                }
                return terms;
            };
            const visitor = (source, parent) => __awaiter(this, void 0, void 0, function* () {
                const children = yield source.children.select("*", "customSortOrder")();
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    const orderedTerm = Object.assign({ children: [], defaultLabel: child.labels.find(l => l.isDefault).name }, child);
                    if (child.childrenCount > 0) {
                        yield visitor(this.getTermById(children[i].id), orderedTerm.children);
                        orderedTerm.children = ensureOrder(orderedTerm.children, child.customSortOrder);
                    }
                    parent.push(orderedTerm);
                }
            });
            yield visitor(this, tree);
            return ensureOrder(tree, null, setInfo.customSortOrder);
        });
    }
}
export const TermSet = spInvokableFactory(_TermSet);
let _Children = class _Children extends _SharePointQueryableCollection {
};
_Children = __decorate([
    defaultPath("children")
], _Children);
export { _Children };
export const Children = spInvokableFactory(_Children);
let _Terms = class _Terms extends _SharePointQueryableCollection {
    /**
     * Gets a term group by id
     *
     * @param id Id of the term group to access
     */
    getById(id) {
        return Term(this, id);
    }
};
_Terms = __decorate([
    defaultPath("terms")
], _Terms);
export { _Terms };
export const Terms = spInvokableFactory(_Terms);
export class _Term extends _SharePointQueryableInstance {
    get children() {
        return tag.configure(Children(this), "txt.children");
    }
    get relations() {
        return tag.configure(Relations(this), "txt.relations");
    }
    get set() {
        return tag.configure(TermSet(this, "set"), "txt.set");
    }
}
export const Term = spInvokableFactory(_Term);
let _Relations = class _Relations extends _SharePointQueryableCollection {
    /**
     * Gets a term group by id
     *
     * @param id Id of the term group to access
     */
    getById(id) {
        return tag.configure(Relation(this, id), "txrs.getById");
    }
};
_Relations = __decorate([
    defaultPath("relations")
], _Relations);
export { _Relations };
export const Relations = spInvokableFactory(_Relations);
export class _Relation extends _SharePointQueryableInstance {
    get fromTerm() {
        return tag.configure(Term(this, "fromTerm"), "txr.fromTerm");
    }
    get toTerm() {
        return tag.configure(Term(this, "toTerm"), "txr.toTerm");
    }
    get set() {
        return tag.configure(TermSet(this, "set"), "txr.set");
    }
}
export const Relation = spInvokableFactory(_Relation);
//# sourceMappingURL=types.js.map