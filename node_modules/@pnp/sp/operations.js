import { __awaiter } from "tslib";
import { defaultPipelineBinder, cloneQueryableData, headers } from "@pnp/odata";
import { SPHttpClient } from "./sphttpclient.js";
import { mergeOptions, objectDefinedNotNull, isFunc } from "@pnp/common";
import { toAbsoluteUrl } from "./utils/toabsoluteurl.js";
export function registerCustomRequestClientFactory(requestClientFactory) {
    httpClientFactory = isFunc(requestClientFactory) ? () => requestClientFactory : defaultFactory;
}
const defaultFactory = (runtime) => () => new SPHttpClient(runtime);
let httpClientFactory = defaultFactory;
const send = (method) => {
    return function (o, options) {
        return __awaiter(this, void 0, void 0, function* () {
            // use the current runtime
            const runtime = o.getRuntime();
            const operation = defaultPipelineBinder(httpClientFactory(runtime))(method);
            const data = cloneQueryableData(o.data);
            const batchDependency = objectDefinedNotNull(data.batch) ? data.batch.addDependency() : () => {
                return;
            };
            const url = yield toAbsoluteUrl(o.toUrlAndQuery(), runtime);
            mergeOptions(data.options, options);
            return operation(Object.assign({}, data, {
                batchDependency,
                url,
            }));
        });
    };
};
export const spGet = (o, options) => {
    // Fix for #304 - when we clone objects we in some cases then execute a get request
    // in these cases the caching settings were getting dropped from the request
    // this tracks if the object from which this was cloned was caching and applies that to an immediate get request
    // does not affect objects cloned from this as we are using different fields to track the settings so it won't
    // be triggered
    if (o.data.cloneParentWasCaching) {
        o.usingCaching(o.data.cloneParentCacheOptions);
    }
    // if we are forcing caching set that in the data here
    if (o._forceCaching) {
        o.data.useCaching = true;
    }
    return send("GET")(o, options);
};
export const spPost = (o, options) => send("POST")(o, options);
export const spDelete = (o, options) => send("DELETE")(o, options);
export const spPatch = (o, options) => send("PATCH")(o, options);
export const spPostDelete = (o, options) => {
    const opts = Object.assign(headers({ "X-HTTP-Method": "DELETE" }), options);
    return spPost(o, opts);
};
export const spPostDeleteETag = (o, options, eTag = "*") => {
    const opts = Object.assign(headers({ "X-HTTP-Method": "DELETE", "IF-Match": eTag }), options);
    return spPost(o, opts);
};
//# sourceMappingURL=operations.js.map