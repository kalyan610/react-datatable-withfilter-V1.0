import { __awaiter, __decorate } from "tslib";
import { assign, dateAdd, hOP, isArray, objectDefinedNotNull } from "@pnp/common";
import { body, headers } from "@pnp/odata";
import { SharePointQueryable, SharePointQueryableCollection, _SharePointQueryableInstance, _SharePointQueryableCollection, spInvokableFactory, deleteableWithETag, } from "../sharepointqueryable.js";
import { odataUrlFrom } from "../odata.js";
import { metadata } from "../utils/metadata.js";
import { defaultPath } from "../decorators.js";
import { spPost } from "../operations.js";
import { escapeQueryStrValue } from "../utils/escapeQueryStrValue.js";
import { tag } from "../telemetry.js";
import { toResourcePath } from "../utils/toResourcePath.js";
let _Lists = class _Lists extends _SharePointQueryableCollection {
    /**
     * Gets a list from the collection by guid id
     *
     * @param id The Id of the list (GUID)
     */
    getById(id) {
        return tag.configure(List(this).concat(`('${id}')`), "ls.getById");
    }
    /**
     * Gets a list from the collection by title
     *
     * @param title The title of the list
     */
    getByTitle(title) {
        return tag.configure(List(this, `getByTitle('${escapeQueryStrValue(title)}')`), "ls.getByTitle");
    }
    /**
     * Adds a new list to the collection
     *
     * @param title The new list's title
     * @param description The new list's description
     * @param template The list template value
     * @param enableContentTypes If true content types will be allowed and enabled, otherwise they will be disallowed and not enabled
     * @param additionalSettings Will be passed as part of the list creation body
     */
    add(title, desc = "", template = 100, enableContentTypes = false, additionalSettings = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const addSettings = Object.assign({
                "AllowContentTypes": enableContentTypes,
                "BaseTemplate": template,
                "ContentTypesEnabled": enableContentTypes,
                "Description": desc,
                "Title": title,
            }, metadata("SP.List"), additionalSettings);
            const data = yield spPost(this, body(addSettings));
            return { data, list: this.getByTitle(addSettings.Title) };
        });
    }
    /**
     * Ensures that the specified list exists in the collection (note: this method not supported for batching)
     *
     * @param title The new list's title
     * @param desc The new list's description
     * @param template The list template value
     * @param enableContentTypes If true content types will be allowed and enabled, otherwise they will be disallowed and not enabled
     * @param additionalSettings Will be passed as part of the list creation body or used to update an existing list
     */
    ensure(title, desc = "", template = 100, enableContentTypes = false, additionalSettings = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.hasBatch) {
                throw Error("The ensure list method is not supported for use in a batch.");
            }
            const addOrUpdateSettings = assign(additionalSettings, { Title: title, Description: desc, ContentTypesEnabled: enableContentTypes }, true);
            const list = this.getByTitle(addOrUpdateSettings.Title);
            try {
                // this will throw if the list doesn't exist
                yield list.select("Title")();
                const data = yield list.update(addOrUpdateSettings).then(r => r.data);
                return { created: false, data, list: this.getByTitle(addOrUpdateSettings.Title) };
            }
            catch (e) {
                const data = yield this.add(title, desc, template, enableContentTypes, addOrUpdateSettings).then(r => r.data);
                return { created: true, data, list: this.getByTitle(addOrUpdateSettings.Title) };
            }
        });
    }
    /**
     * Gets a list that is the default asset location for images or other files, which the users upload to their wiki pages.
     */
    ensureSiteAssetsLibrary() {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield spPost(this.clone(Lists, "ensuresiteassetslibrary"));
            return List(odataUrlFrom(json));
        });
    }
    /**
     * Gets a list that is the default location for wiki pages.
     */
    ensureSitePagesLibrary() {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield spPost(this.clone(Lists, "ensuresitepageslibrary"));
            return List(odataUrlFrom(json));
        });
    }
};
__decorate([
    tag("ls.add")
], _Lists.prototype, "add", null);
__decorate([
    tag("ls.ensure")
], _Lists.prototype, "ensure", null);
__decorate([
    tag("ls.ensureSiteAssetsLibrary")
], _Lists.prototype, "ensureSiteAssetsLibrary", null);
__decorate([
    tag("ls.ensureSitePagesLibrary")
], _Lists.prototype, "ensureSitePagesLibrary", null);
_Lists = __decorate([
    defaultPath("lists")
], _Lists);
export { _Lists };
export const Lists = spInvokableFactory(_Lists);
export class _List extends _SharePointQueryableInstance {
    constructor() {
        super(...arguments);
        this.delete = deleteableWithETag("l");
    }
    /**
     * Gets the effective base permissions of this list
     *
     */
    get effectiveBasePermissions() {
        return tag.configure(SharePointQueryable(this, "EffectiveBasePermissions"), "l.effectiveBasePermissions");
    }
    /**
     * Gets the event receivers attached to this list
     *
     */
    get eventReceivers() {
        return tag.configure(SharePointQueryableCollection(this, "EventReceivers"), "l.eventReceivers");
    }
    /**
     * Gets the related fields of this list
     *
     */
    get relatedFields() {
        return tag.configure(SharePointQueryable(this, "getRelatedFields"), "l.relatedFields");
    }
    /**
     * Gets the IRM settings for this list
     *
     */
    get informationRightsManagementSettings() {
        return tag.configure(SharePointQueryable(this, "InformationRightsManagementSettings"), "l.informationRightsManagementSettings");
    }
    /**
     * Updates this list intance with the supplied properties
     *
     * @param properties A plain object hash of values to update for the list
     * @param eTag Value used in the IF-Match header, by default "*"
     */
    update(properties, eTag = "*") {
        return __awaiter(this, void 0, void 0, function* () {
            const postBody = body(assign(metadata("SP.List"), properties), headers({
                "IF-Match": eTag,
                "X-HTTP-Method": "MERGE",
            }));
            const data = yield spPost(this, postBody);
            const list = hOP(properties, "Title") ? this.getParent(List, this.parentUrl, `getByTitle('${properties.Title}')`) : List(this);
            return {
                data,
                list,
            };
        });
    }
    /**
     * Returns the collection of changes from the change log that have occurred within the list, based on the specified query.
     * @param query A query that is performed against the change log.
     */
    getChanges(query) {
        return spPost(this.clone(List, "getchanges"), body({ query: assign(metadata("SP.ChangeQuery"), query) }));
    }
    /**
     * Returns the collection of items in the list based on the provided CamlQuery
     * @param query A query that is performed against the list
     * @param expands An expanded array of n items that contains fields to expand in the CamlQuery
     */
    getItemsByCAMLQuery(query, ...expands) {
        const q = this.clone(List, "getitems");
        return spPost(q.expand(...expands), body({ query: assign(metadata("SP.CamlQuery"), query) }));
    }
    /**
     * See: https://msdn.microsoft.com/en-us/library/office/dn292554.aspx
     * @param query An object that defines the change log item query
     */
    getListItemChangesSinceToken(query) {
        const o = this.clone(List, "getlistitemchangessincetoken").usingParser({
            parse(r) {
                return r.text();
            },
        });
        return spPost(o, body({ "query": assign(metadata("SP.ChangeLogItemQuery"), query) }));
    }
    /**
     * Moves the list to the Recycle Bin and returns the identifier of the new Recycle Bin item.
     */
    recycle() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield spPost(this.clone(List, "recycle"));
            return hOP(data, "Recycle") ? data.Recycle : data;
        });
    }
    /**
     * Renders list data based on the view xml provided
     * @param viewXml A string object representing a view xml
     */
    renderListData(viewXml) {
        return __awaiter(this, void 0, void 0, function* () {
            const q = this.clone(List, "renderlistdata(@viewXml)");
            q.query.set("@viewXml", `'${viewXml}'`);
            const data = yield spPost(q);
            // data will be a string, so we parse it again
            return JSON.parse(hOP(data, "RenderListData") ? data.RenderListData : data);
        });
    }
    /**
     * Returns the data for the specified query view
     *
     * @param parameters The parameters to be used to render list data as JSON string.
     * @param overrideParams The parameters that are used to override and extend the regular SPRenderListDataParameters.
     * @param query Allows setting of query parameters
     */
    renderListDataAsStream(parameters, overrideParams = null, query = new Map()) {
        if (hOP(parameters, "RenderOptions") && isArray(parameters.RenderOptions)) {
            parameters.RenderOptions = parameters.RenderOptions.reduce((v, c) => v + c);
        }
        let bodyOptions = { parameters: assign(metadata("SP.RenderListDataParameters"), parameters) };
        if (objectDefinedNotNull(overrideParams)) {
            bodyOptions = assign(bodyOptions, { overrideParameters: assign(metadata("SP.RenderListDataOverrideParameters"), overrideParams) });
        }
        const clone = this.clone(List, "RenderListDataAsStream", true, true);
        if (query && query.size > 0) {
            query.forEach((v, k) => clone.query.set(k, v));
        }
        return spPost(clone, body(bodyOptions));
    }
    /**
     * Gets the field values and field schema attributes for a list item.
     * @param itemId Item id of the item to render form data for
     * @param formId The id of the form
     * @param mode Enum representing the control mode of the form (Display, Edit, New)
     */
    renderListFormData(itemId, formId, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield spPost(this.clone(List, `renderlistformdata(itemid=${itemId}, formid='${formId}', mode='${mode}')`));
            // data will be a string, so we parse it again
            return JSON.parse(hOP(data, "RenderListFormData") ? data.RenderListFormData : data);
        });
    }
    /**
     * Reserves a list item ID for idempotent list item creation.
     */
    reserveListItemId() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield spPost(this.clone(List, "reservelistitemid"));
            return hOP(data, "ReserveListItemId") ? data.ReserveListItemId : data;
        });
    }
    /**
     * Returns the ListItemEntityTypeFullName for this list, used when adding/updating list items. Does not support batching.
     */
    getListItemEntityTypeFullName() {
        // we cache these requests as the entity name doesn't change and we can save traffic
        // this is justified as this method generates our second highest number of monthly executions ahead of item add and update
        return this.clone(List, null, false).select("ListItemEntityTypeFullName").usingCaching({
            expiration: dateAdd(new Date(), "day", 5),
            key: `PnPjs-ListEntityName:${this.toUrl()}`,
            storeName: "local",
        })().then(o => o.ListItemEntityTypeFullName);
    }
    /**
     * Creates an item using path (in a folder), validates and sets its field values.
     *
     * @param formValues The fields to change and their new values.
     * @param decodedUrl Path decoded url; folder's server relative path.
     * @param bNewDocumentUpdate true if the list item is a document being updated after upload; otherwise false.
     * @param checkInComment Optional check in comment.
     * @param additionalProps Optional set of additional properties LeafName new document file name,
     */
    addValidateUpdateItemUsingPath(formValues, decodedUrl, bNewDocumentUpdate = false, checkInComment, additionalProps) {
        return __awaiter(this, void 0, void 0, function* () {
            const addProps = {
                FolderPath: toResourcePath(decodedUrl),
            };
            if (objectDefinedNotNull(additionalProps)) {
                if (additionalProps.leafName) {
                    addProps.LeafName = toResourcePath(additionalProps.leafName);
                }
                if (additionalProps.objectType) {
                    addProps.UnderlyingObjectType = additionalProps.objectType;
                }
            }
            const res = yield spPost(this.clone(List, "AddValidateUpdateItemUsingPath()"), body({
                bNewDocumentUpdate,
                checkInComment,
                formValues,
                listItemCreateInfo: assign(metadata("SP.ListItemCreationInformationUsingPath"), addProps),
            }));
            return hOP(res, "AddValidateUpdateItemUsingPath") ? res.AddValidateUpdateItemUsingPath : res;
        });
    }
    /**
     * Gets the parent information for this item's list and web
     */
    getParentInfos() {
        return __awaiter(this, void 0, void 0, function* () {
            const urlInfo = yield this.select("Id", "RootFolder/UniqueId", "RootFolder/ServerRelativeUrl", "RootFolder/ServerRelativePath", "ParentWeb/Id", "ParentWeb/Url", "ParentWeb/ServerRelativeUrl", "ParentWeb/ServerRelativePath").expand("RootFolder", "ParentWeb")();
            return {
                List: {
                    Id: urlInfo.Id,
                    RootFolderServerRelativePath: urlInfo.RootFolder.ServerRelativePath,
                    RootFolderServerRelativeUrl: urlInfo.RootFolder.ServerRelativeUrl,
                    RootFolderUniqueId: urlInfo.RootFolder.UniqueId,
                },
                ParentWeb: {
                    Id: urlInfo.ParentWeb.Id,
                    ServerRelativePath: urlInfo.ParentWeb.ServerRelativePath,
                    ServerRelativeUrl: urlInfo.ParentWeb.ServerRelativeUrl,
                    Url: urlInfo.ParentWeb.Url,
                },
            };
        });
    }
}
__decorate([
    tag("l.update")
], _List.prototype, "update", null);
__decorate([
    tag("l.getChanges")
], _List.prototype, "getChanges", null);
__decorate([
    tag("l.CAMLQuery")
], _List.prototype, "getItemsByCAMLQuery", null);
__decorate([
    tag("l.ChangesSinceToken")
], _List.prototype, "getListItemChangesSinceToken", null);
__decorate([
    tag("l.recycle")
], _List.prototype, "recycle", null);
__decorate([
    tag("l.renderListData")
], _List.prototype, "renderListData", null);
__decorate([
    tag("l.AsStream")
], _List.prototype, "renderListDataAsStream", null);
__decorate([
    tag("l.renderListFormData")
], _List.prototype, "renderListFormData", null);
__decorate([
    tag("l.reserveListItemId")
], _List.prototype, "reserveListItemId", null);
__decorate([
    tag("l.getListItemEntityTypeFullName")
], _List.prototype, "getListItemEntityTypeFullName", null);
__decorate([
    tag("l.addValidateUpdateItemUsingPath")
], _List.prototype, "addValidateUpdateItemUsingPath", null);
export const List = spInvokableFactory(_List);
/**
 * Enum representing the options of the RenderOptions property on IRenderListDataParameters interface
 */
export var RenderListDataOptions;
(function (RenderListDataOptions) {
    RenderListDataOptions[RenderListDataOptions["None"] = 0] = "None";
    RenderListDataOptions[RenderListDataOptions["ContextInfo"] = 1] = "ContextInfo";
    RenderListDataOptions[RenderListDataOptions["ListData"] = 2] = "ListData";
    RenderListDataOptions[RenderListDataOptions["ListSchema"] = 4] = "ListSchema";
    RenderListDataOptions[RenderListDataOptions["MenuView"] = 8] = "MenuView";
    RenderListDataOptions[RenderListDataOptions["ListContentType"] = 16] = "ListContentType";
    RenderListDataOptions[RenderListDataOptions["FileSystemItemId"] = 32] = "FileSystemItemId";
    RenderListDataOptions[RenderListDataOptions["ClientFormSchema"] = 64] = "ClientFormSchema";
    RenderListDataOptions[RenderListDataOptions["QuickLaunch"] = 128] = "QuickLaunch";
    RenderListDataOptions[RenderListDataOptions["Spotlight"] = 256] = "Spotlight";
    RenderListDataOptions[RenderListDataOptions["Visualization"] = 512] = "Visualization";
    RenderListDataOptions[RenderListDataOptions["ViewMetadata"] = 1024] = "ViewMetadata";
    RenderListDataOptions[RenderListDataOptions["DisableAutoHyperlink"] = 2048] = "DisableAutoHyperlink";
    RenderListDataOptions[RenderListDataOptions["EnableMediaTAUrls"] = 4096] = "EnableMediaTAUrls";
    RenderListDataOptions[RenderListDataOptions["ParentInfo"] = 8192] = "ParentInfo";
    RenderListDataOptions[RenderListDataOptions["PageContextInfo"] = 16384] = "PageContextInfo";
    RenderListDataOptions[RenderListDataOptions["ClientSideComponentManifest"] = 32768] = "ClientSideComponentManifest";
})(RenderListDataOptions || (RenderListDataOptions = {}));
/**
 * Determines the display mode of the given control or view
 */
export var ControlMode;
(function (ControlMode) {
    ControlMode[ControlMode["Display"] = 1] = "Display";
    ControlMode[ControlMode["Edit"] = 2] = "Edit";
    ControlMode[ControlMode["New"] = 3] = "New";
})(ControlMode || (ControlMode = {}));
//# sourceMappingURL=types.js.map