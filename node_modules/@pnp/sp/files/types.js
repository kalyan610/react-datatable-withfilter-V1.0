import { __awaiter, __decorate } from "tslib";
import { _SharePointQueryableInstance, _SharePointQueryableCollection, spInvokableFactory, SharePointQueryableInstance, deleteableWithETag, } from "../sharepointqueryable.js";
import { TextParser, BlobParser, JSONParser, BufferParser, headers, body } from "@pnp/odata";
import { assign, getGUID, isFunc, stringIsNullOrEmpty, isUrlAbsolute } from "@pnp/common";
import { Item } from "../items/index.js";
import { odataUrlFrom } from "../odata.js";
import { defaultPath } from "../decorators.js";
import { spPost } from "../operations.js";
import { escapeQueryStrValue } from "../utils/escapeQueryStrValue.js";
import { extractWebUrl } from "../utils/extractweburl.js";
import { tag } from "../telemetry.js";
import { toResourcePath } from "../utils/toResourcePath.js";
/**
 * Describes a collection of File objects
 *
 */
let _Files = class _Files extends _SharePointQueryableCollection {
    /**
     * Gets a File by filename
     *
     * @param name The name of the file, including extension.
     */
    getByName(name) {
        if (/%#/.test(name)) {
            throw Error("For file names containing % or # please use web.getFileByServerRelativePath");
        }
        return tag.configure(File(this).concat(`('${escapeQueryStrValue(name)}')`), "fis.getByName");
    }
    /**
     * Uploads a file. Not supported for batching
     *
     * @param url The folder-relative url of the file.
     * @param content The file contents
     * @param shouldOverWrite Should a file with the same name in the same location be overwritten? (default: true)
     * @returns The new File and the raw response.
     */
    add(url, content, shouldOverWrite = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield spPost(Files(this, `add(overwrite=${shouldOverWrite},url='${escapeQueryStrValue(url)}')`), {
                body: content,
            });
            return {
                data: response,
                file: this.getByName(url),
            };
        });
    }
    /**
     * Adds a file using the pound percent safe methods
     *
     * @param url Excoded url of the file
     * @param content The file content
     * @param parameters Additional parameters to control method behavior
     */
    addUsingPath(url, content, parameters = { Overwrite: false }) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = [`AddUsingPath(decodedurl='${escapeQueryStrValue(url)}'`];
            if (parameters) {
                if (parameters.Overwrite) {
                    path.push(",Overwrite=true");
                }
                if (parameters.AutoCheckoutOnInvalidData) {
                    path.push(",AutoCheckoutOnInvalidData=true");
                }
                if (!stringIsNullOrEmpty(parameters.XorHash)) {
                    path.push(`,XorHash=${escapeQueryStrValue(parameters.XorHash)}`);
                }
            }
            path.push(")");
            const resp = yield spPost(Files(this, path.join("")), { body: content });
            return {
                data: resp,
                file: File(odataUrlFrom(resp)),
            };
        });
    }
    /**
     * Uploads a file. Not supported for batching
     *
     * @param url The folder-relative url of the file.
     * @param content The Blob file content to add
     * @param progress A callback function which can be used to track the progress of the upload
     * @param shouldOverWrite Should a file with the same name in the same location be overwritten? (default: true)
     * @param chunkSize The size of each file slice, in bytes (default: 10485760)
     * @returns The new File and the raw response.
     */
    addChunked(url, content, progress, shouldOverWrite = true, chunkSize = 10485760) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield spPost(this.clone(Files, `add(overwrite=${shouldOverWrite},url='${escapeQueryStrValue(url)}')`, false));
            const file = File(odataUrlFrom(response));
            return yield file.setContentChunked(content, progress, chunkSize);
        });
    }
    /**
     * Adds a ghosted file to an existing list or document library. Not supported for batching.
     *
     * @param fileUrl The server-relative url where you want to save the file.
     * @param templateFileType The type of use to create the file.
     * @returns The template file that was added and the raw response.
     */
    addTemplateFile(fileUrl, templateFileType) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield spPost(this.clone(Files, `addTemplateFile(urloffile='${escapeQueryStrValue(fileUrl)}',templatefiletype=${templateFileType})`, false));
            return {
                data: response,
                file: File(odataUrlFrom(response)),
            };
        });
    }
};
__decorate([
    tag("fis.add")
], _Files.prototype, "add", null);
__decorate([
    tag("fis.addUsingPath")
], _Files.prototype, "addUsingPath", null);
__decorate([
    tag("fis.addChunked")
], _Files.prototype, "addChunked", null);
__decorate([
    tag("fis.addTemplateFile")
], _Files.prototype, "addTemplateFile", null);
_Files = __decorate([
    defaultPath("files")
], _Files);
export { _Files };
export const Files = spInvokableFactory(_Files);
/**
 * Describes a single File instance
 *
 */
export class _File extends _SharePointQueryableInstance {
    constructor() {
        super(...arguments);
        this.delete = deleteableWithETag("fi");
    }
    /**
     * Gets a value that specifies the list item field values for the list item corresponding to the file.
     *
     */
    get listItemAllFields() {
        return tag.configure(SharePointQueryableInstance(this, "listItemAllFields"), "fi.listItemAllFields");
    }
    /**
     * Gets a collection of versions
     *
     */
    get versions() {
        return tag.configure(Versions(this), "fi.versions");
    }
    /**
     * Approves the file submitted for content approval with the specified comment.
     * Only documents in lists that are enabled for content approval can be approved.
     *
     * @param comment The comment for the approval.
     */
    approve(comment = "") {
        return spPost(this.clone(File, `approve(comment='${escapeQueryStrValue(comment)}')`));
    }
    /**
     * Stops the chunk upload session without saving the uploaded data. Does not support batching.
     * If the file doesnâ€™t already exist in the library, the partially uploaded file will be deleted.
     * Use this in response to user action (as in a request to cancel an upload) or an error or exception.
     * Use the uploadId value that was passed to the StartUpload method that started the upload session.
     * This method is currently available only on Office 365.
     *
     * @param uploadId The unique identifier of the upload session.
     */
    cancelUpload(uploadId) {
        return spPost(this.clone(File, `cancelUpload(uploadId=guid'${uploadId}')`, false));
    }
    /**
     * Checks the file in to a document library based on the check-in type.
     *
     * @param comment A comment for the check-in. Its length must be <= 1023.
     * @param checkinType The check-in type for the file.
     */
    checkin(comment = "", checkinType = CheckinType.Major) {
        if (comment.length > 1023) {
            throw Error("The maximum comment length is 1023 characters.");
        }
        return spPost(this.clone(File, `checkin(comment='${escapeQueryStrValue(comment)}',checkintype=${checkinType})`));
    }
    /**
     * Checks out the file from a document library.
     */
    checkout() {
        return spPost(this.clone(File, "checkout"));
    }
    /**
     * Copies the file to the destination url.
     *
     * @param url The absolute url or server relative url of the destination file path to copy to.
     * @param shouldOverWrite Should a file with the same name in the same location be overwritten?
     */
    copyTo(url, shouldOverWrite = true) {
        return spPost(this.clone(File, `copyTo(strnewurl='${escapeQueryStrValue(url)}',boverwrite=${shouldOverWrite})`));
    }
    /**
     * Copies the file by path to destination path.
     * Also works with different site collections.
     *
     * @param destUrl The absolute url or server relative url of the destination file path to copy to.
     * @param shouldOverWrite Should a file with the same name in the same location be overwritten?
     * @param keepBoth Keep both if file with the same name in the same location already exists? Only relevant when shouldOverWrite is set to false.
     */
    copyByPath(destUrl, shouldOverWrite, KeepBoth = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const { ServerRelativeUrl: srcUrl, ["odata.id"]: absoluteUrl } = yield this.select("ServerRelativeUrl")();
            const webBaseUrl = extractWebUrl(absoluteUrl);
            const hostUrl = webBaseUrl.replace("://", "___").split("/")[0].replace("___", "://");
            yield spPost(File(webBaseUrl, `/_api/SP.MoveCopyUtil.CopyFileByPath(overwrite=@a1)?@a1=${shouldOverWrite}`), body({
                destPath: toResourcePath(isUrlAbsolute(destUrl) ? destUrl : `${hostUrl}${destUrl}`),
                options: {
                    KeepBoth: KeepBoth,
                    ResetAuthorAndCreatedOnCopy: true,
                    ShouldBypassSharedLocks: true,
                    __metadata: {
                        type: "SP.MoveCopyOptions",
                    },
                },
                srcPath: toResourcePath(isUrlAbsolute(srcUrl) ? srcUrl : `${hostUrl}${srcUrl}`),
            }));
        });
    }
    /**
     * Denies approval for a file that was submitted for content approval.
     * Only documents in lists that are enabled for content approval can be denied.
     *
     * @param comment The comment for the denial.
     */
    deny(comment = "") {
        if (comment.length > 1023) {
            throw Error("The maximum comment length is 1023 characters.");
        }
        return spPost(this.clone(File, `deny(comment='${escapeQueryStrValue(comment)}')`));
    }
    /**
     * Moves the file to the specified destination url.
     *
     * @param url The absolute url or server relative url of the destination file path to move to.
     * @param moveOperations The bitwise MoveOperations value for how to move the file.
     */
    moveTo(url, moveOperations = MoveOperations.Overwrite) {
        return spPost(this.clone(File, `moveTo(newurl='${escapeQueryStrValue(url)}',flags=${moveOperations})`));
    }
    /**
     * Moves the file by path to the specified destination url.
     * Also works with different site collections.
     *
     * @param destUrl The absolute url or server relative url of the destination file path to move to.
     * @param shouldOverWrite Should a file with the same name in the same location be overwritten?
     * @param keepBoth Keep both if file with the same name in the same location already exists? Only relevant when shouldOverWrite is set to false.
     */
    moveByPath(destUrl, shouldOverWrite, KeepBoth = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const { ServerRelativeUrl: srcUrl, ["odata.id"]: absoluteUrl } = yield this.select("ServerRelativeUrl")();
            const webBaseUrl = extractWebUrl(absoluteUrl);
            const hostUrl = webBaseUrl.replace("://", "___").split("/")[0].replace("___", "://");
            yield spPost(File(webBaseUrl, `/_api/SP.MoveCopyUtil.MoveFileByPath(overwrite=@a1)?@a1=${shouldOverWrite}`), body({
                destPath: toResourcePath(isUrlAbsolute(destUrl) ? destUrl : `${hostUrl}${destUrl}`),
                options: {
                    KeepBoth: KeepBoth,
                    ResetAuthorAndCreatedOnCopy: false,
                    ShouldBypassSharedLocks: true,
                    __metadata: {
                        type: "SP.MoveCopyOptions",
                    },
                },
                srcPath: toResourcePath(isUrlAbsolute(srcUrl) ? srcUrl : `${hostUrl}${srcUrl}`),
            }));
        });
    }
    /**
     * Submits the file for content approval with the specified comment.
     *
     * @param comment The comment for the published file. Its length must be <= 1023.
     */
    publish(comment = "") {
        if (comment.length > 1023) {
            throw Error("The maximum comment length is 1023 characters.");
        }
        return spPost(this.clone(File, `publish(comment='${escapeQueryStrValue(comment)}')`));
    }
    /**
     * Moves the file to the Recycle Bin and returns the identifier of the new Recycle Bin item.
     *
     * @returns The GUID of the recycled file.
     */
    recycle() {
        return spPost(this.clone(File, "recycle"));
    }
    /**
     * Deletes the file object with options.
     *
     * @param parameters Specifies the options to use when deleting a file.
     */
    deleteWithParams(parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            return spPost(this.clone(File, "DeleteWithParameters"), body({ parameters }));
        });
    }
    /**
     * Reverts an existing checkout for the file.
     *
     */
    undoCheckout() {
        return spPost(this.clone(File, "undoCheckout"));
    }
    /**
     * Removes the file from content approval or unpublish a major version.
     *
     * @param comment The comment for the unpublish operation. Its length must be <= 1023.
     */
    unpublish(comment = "") {
        if (comment.length > 1023) {
            throw Error("The maximum comment length is 1023 characters.");
        }
        return spPost(this.clone(File, `unpublish(comment='${escapeQueryStrValue(comment)}')`));
    }
    /**
     * Checks to see if the file represented by this object exists
     *
     */
    exists() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const r = yield this.clone(File).select("Exists")();
                return r.Exists;
            }
            catch (e) {
                // this treats any error here as the file not existing, which
                // might not be true, but is good enough.
                return false;
            }
        });
    }
    /**
     * Gets the contents of the file as text. Not supported in batching.
     *
     */
    getText() {
        return this.clone(File, "$value", false).usingParser(new TextParser())(headers({ "binaryStringResponseBody": "true" }));
    }
    /**
     * Gets the contents of the file as a blob, does not work in Node.js. Not supported in batching.
     *
     */
    getBlob() {
        return this.clone(File, "$value", false).usingParser(new BlobParser())(headers({ "binaryStringResponseBody": "true" }));
    }
    /**
     * Gets the contents of a file as an ArrayBuffer, works in Node.js. Not supported in batching.
     */
    getBuffer() {
        return this.clone(File, "$value", false).usingParser(new BufferParser())(headers({ "binaryStringResponseBody": "true" }));
    }
    /**
     * Gets the contents of a file as an ArrayBuffer, works in Node.js. Not supported in batching.
     */
    getJSON() {
        return this.clone(File, "$value", false).usingParser(new JSONParser())(headers({ "binaryStringResponseBody": "true" }));
    }
    /**
     * Sets the content of a file, for large files use setContentChunked. Not supported in batching.
     *
     * @param content The file content
     *
     */
    setContent(content) {
        return __awaiter(this, void 0, void 0, function* () {
            yield spPost(this.clone(File, "$value", false), {
                body: content,
                headers: {
                    "X-HTTP-Method": "PUT",
                },
            });
            return File(this);
        });
    }
    /**
     * Gets the associated list item for this folder, loading the default properties
     */
    getItem(...selects) {
        return __awaiter(this, void 0, void 0, function* () {
            const q = this.listItemAllFields;
            const d = yield q.select(...selects)();
            return assign(Item(odataUrlFrom(d)), d);
        });
    }
    /**
     * Sets the contents of a file using a chunked upload approach. Not supported in batching.
     *
     * @param file The file to upload
     * @param progress A callback function which can be used to track the progress of the upload
     * @param chunkSize The size of each file slice, in bytes (default: 10485760)
     */
    setContentChunked(file, progress, chunkSize = 10485760) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!isFunc(progress)) {
                progress = () => null;
            }
            const fileSize = file.size;
            const totalBlocks = parseInt((fileSize / chunkSize).toString(), 10) + ((fileSize % chunkSize === 0) ? 1 : 0);
            const uploadId = getGUID();
            // report that we are starting
            progress({ uploadId, blockNumber: 1, chunkSize, currentPointer: 0, fileSize, stage: "starting", totalBlocks });
            let currentPointer = yield this.startUpload(uploadId, file.slice(0, chunkSize));
            // skip the first and last blocks
            for (let i = 2; i < totalBlocks; i++) {
                progress({ uploadId, blockNumber: i, chunkSize, currentPointer, fileSize, stage: "continue", totalBlocks });
                currentPointer = yield this.continueUpload(uploadId, currentPointer, file.slice(currentPointer, currentPointer + chunkSize));
            }
            progress({ uploadId, blockNumber: totalBlocks, chunkSize, currentPointer, fileSize, stage: "finishing", totalBlocks });
            return this.finishUpload(uploadId, currentPointer, file.slice(currentPointer));
        });
    }
    /**
     * Starts a new chunk upload session and uploads the first fragment.
     * The current file content is not changed when this method completes.
     * The method is idempotent (and therefore does not change the result) as long as you use the same values for uploadId and stream.
     * The upload session ends either when you use the CancelUpload method or when you successfully
     * complete the upload session by passing the rest of the file contents through the ContinueUpload and FinishUpload methods.
     * The StartUpload and ContinueUpload methods return the size of the running total of uploaded data in bytes,
     * so you can pass those return values to subsequent uses of ContinueUpload and FinishUpload.
     * This method is currently available only on Office 365.
     *
     * @param uploadId The unique identifier of the upload session.
     * @param fragment The file contents.
     * @returns The size of the total uploaded data in bytes.
     */
    startUpload(uploadId, fragment) {
        return __awaiter(this, void 0, void 0, function* () {
            let n = yield spPost(this.clone(File, `startUpload(uploadId=guid'${uploadId}')`, false), { body: fragment });
            if (typeof n === "object") {
                // When OData=verbose the payload has the following shape:
                // { StartUpload: "10485760" }
                n = n.StartUpload;
            }
            return parseFloat(n);
        });
    }
    /**
     * Continues the chunk upload session with an additional fragment.
     * The current file content is not changed.
     * Use the uploadId value that was passed to the StartUpload method that started the upload session.
     * This method is currently available only on Office 365.
     *
     * @param uploadId The unique identifier of the upload session.
     * @param fileOffset The size of the offset into the file where the fragment starts.
     * @param fragment The file contents.
     * @returns The size of the total uploaded data in bytes.
     */
    continueUpload(uploadId, fileOffset, fragment) {
        return __awaiter(this, void 0, void 0, function* () {
            let n = yield spPost(this.clone(File, `continueUpload(uploadId=guid'${uploadId}',fileOffset=${fileOffset})`, false), { body: fragment });
            if (typeof n === "object") {
                // When OData=verbose the payload has the following shape:
                // { ContinueUpload: "20971520" }
                n = n.ContinueUpload;
            }
            return parseFloat(n);
        });
    }
    /**
     * Uploads the last file fragment and commits the file. The current file content is changed when this method completes.
     * Use the uploadId value that was passed to the StartUpload method that started the upload session.
     * This method is currently available only on Office 365.
     *
     * @param uploadId The unique identifier of the upload session.
     * @param fileOffset The size of the offset into the file where the fragment starts.
     * @param fragment The file contents.
     * @returns The newly uploaded file.
     */
    finishUpload(uploadId, fileOffset, fragment) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield spPost(this.clone(File, `finishUpload(uploadId=guid'${uploadId}',fileOffset=${fileOffset})`, false), { body: fragment });
            return {
                data: response,
                file: File(odataUrlFrom(response)),
            };
        });
    }
}
__decorate([
    tag("fi.approve")
], _File.prototype, "approve", null);
__decorate([
    tag("fi.cancelUpload")
], _File.prototype, "cancelUpload", null);
__decorate([
    tag("fi.checkin")
], _File.prototype, "checkin", null);
__decorate([
    tag("fi.checkout")
], _File.prototype, "checkout", null);
__decorate([
    tag("fi.copyTo")
], _File.prototype, "copyTo", null);
__decorate([
    tag("fi.copyByPath")
], _File.prototype, "copyByPath", null);
__decorate([
    tag("fi.deny")
], _File.prototype, "deny", null);
__decorate([
    tag("fi.moveTo")
], _File.prototype, "moveTo", null);
__decorate([
    tag("fi.moveByPath")
], _File.prototype, "moveByPath", null);
__decorate([
    tag("fi.publish")
], _File.prototype, "publish", null);
__decorate([
    tag("fi.recycle")
], _File.prototype, "recycle", null);
__decorate([
    tag("fi.del-params")
], _File.prototype, "deleteWithParams", null);
__decorate([
    tag("fi.undoCheckout")
], _File.prototype, "undoCheckout", null);
__decorate([
    tag("fi.unpublish")
], _File.prototype, "unpublish", null);
__decorate([
    tag("fi.exists")
], _File.prototype, "exists", null);
__decorate([
    tag("fi.getText")
], _File.prototype, "getText", null);
__decorate([
    tag("fi.getBlob")
], _File.prototype, "getBlob", null);
__decorate([
    tag("fi.getBuffer")
], _File.prototype, "getBuffer", null);
__decorate([
    tag("fi.getJSON")
], _File.prototype, "getJSON", null);
__decorate([
    tag("fi.setContent")
], _File.prototype, "setContent", null);
__decorate([
    tag("fi.getItem")
], _File.prototype, "getItem", null);
__decorate([
    tag("fi.startUpload")
], _File.prototype, "startUpload", null);
__decorate([
    tag("fi.continueUpload")
], _File.prototype, "continueUpload", null);
__decorate([
    tag("fi.finishUpload")
], _File.prototype, "finishUpload", null);
export const File = spInvokableFactory(_File);
/**
 * Describes a collection of Version objects
 *
 */
let _Versions = class _Versions extends _SharePointQueryableCollection {
    /**
     * Gets a version by id
     *
     * @param versionId The id of the version to retrieve
     */
    getById(versionId) {
        return tag.configure(Version(this).concat(`(${versionId})`), "vers.getById");
    }
    /**
     * Deletes all the file version objects in the collection.
     *
     */
    deleteAll() {
        return spPost(Versions(this, "deleteAll"));
    }
    /**
     * Deletes the specified version of the file.
     *
     * @param versionId The ID of the file version to delete.
     */
    deleteById(versionId) {
        return spPost(this.clone(Versions, `deleteById(vid=${versionId})`));
    }
    /**
     * Recycles the specified version of the file.
     *
     * @param versionId The ID of the file version to delete.
     */
    recycleByID(versionId) {
        return spPost(this.clone(Versions, `recycleByID(vid=${versionId})`));
    }
    /**
     * Deletes the file version object with the specified version label.
     *
     * @param label The version label of the file version to delete, for example: 1.2
     */
    deleteByLabel(label) {
        return spPost(this.clone(Versions, `deleteByLabel(versionlabel='${escapeQueryStrValue(label)}')`));
    }
    /**
     * Recycles the file version object with the specified version label.
     *
     * @param label The version label of the file version to delete, for example: 1.2
     */
    recycleByLabel(label) {
        return spPost(this.clone(Versions, `recycleByLabel(versionlabel='${escapeQueryStrValue(label)}')`));
    }
    /**
     * Creates a new file version from the file specified by the version label.
     *
     * @param label The version label of the file version to restore, for example: 1.2
     */
    restoreByLabel(label) {
        return spPost(this.clone(Versions, `restoreByLabel(versionlabel='${escapeQueryStrValue(label)}')`));
    }
};
__decorate([
    tag("vers.deleteAll")
], _Versions.prototype, "deleteAll", null);
__decorate([
    tag("vers.deleteById")
], _Versions.prototype, "deleteById", null);
__decorate([
    tag("vers.recycleByID")
], _Versions.prototype, "recycleByID", null);
__decorate([
    tag("vers.deleteByLabel")
], _Versions.prototype, "deleteByLabel", null);
__decorate([
    tag("vers.recycleByLabel")
], _Versions.prototype, "recycleByLabel", null);
__decorate([
    tag("vers.restoreByLabel")
], _Versions.prototype, "restoreByLabel", null);
_Versions = __decorate([
    defaultPath("versions")
], _Versions);
export { _Versions };
export const Versions = spInvokableFactory(_Versions);
/**
 * Describes a single Version instance
 *
 */
export class _Version extends _SharePointQueryableInstance {
    constructor() {
        super(...arguments);
        this.delete = deleteableWithETag("ver");
    }
}
export const Version = spInvokableFactory(_Version);
/**
 * Types for document check in.
 * Minor = 0
 * Major = 1
 * Overwrite = 2
 */
export var CheckinType;
(function (CheckinType) {
    CheckinType[CheckinType["Minor"] = 0] = "Minor";
    CheckinType[CheckinType["Major"] = 1] = "Major";
    CheckinType[CheckinType["Overwrite"] = 2] = "Overwrite";
})(CheckinType || (CheckinType = {}));
/**
 * File move opertions
 * Overwrite = 1
 * AllowBrokenThickets = 8
 */
export var MoveOperations;
(function (MoveOperations) {
    MoveOperations[MoveOperations["Overwrite"] = 1] = "Overwrite";
    MoveOperations[MoveOperations["AllowBrokenThickets"] = 8] = "AllowBrokenThickets";
})(MoveOperations || (MoveOperations = {}));
export var TemplateFileType;
(function (TemplateFileType) {
    TemplateFileType[TemplateFileType["StandardPage"] = 0] = "StandardPage";
    TemplateFileType[TemplateFileType["WikiPage"] = 1] = "WikiPage";
    TemplateFileType[TemplateFileType["FormPage"] = 2] = "FormPage";
    TemplateFileType[TemplateFileType["ClientSidePage"] = 3] = "ClientSidePage";
})(TemplateFileType || (TemplateFileType = {}));
//# sourceMappingURL=types.js.map