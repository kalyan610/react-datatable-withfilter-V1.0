import { assign, combine, hOP, isUrlAbsolute } from "@pnp/common";
import { Logger } from "@pnp/logging";
import { ODataParser } from "@pnp/odata";
import { extractWebUrl } from "./utils/extractweburl.js";
export function odataUrlFrom(candidate) {
    const parts = [];
    const s = ["odata.type", "odata.editLink", "__metadata", "odata.metadata", "odata.id"];
    if (hOP(candidate, s[0]) && candidate[s[0]] === "SP.Web") {
        // webs return an absolute url in the id
        if (hOP(candidate, s[4])) {
            parts.push(candidate[s[4]]);
        }
        else if (hOP(candidate, s[2])) {
            // we are dealing with verbose, which has an absolute uri
            parts.push(candidate.__metadata.uri);
        }
    }
    else {
        if (hOP(candidate, s[3]) && hOP(candidate, s[1])) {
            // we are dealign with minimal metadata (default)
            // some entities return an abosolute url in the editlink while for others it is relative
            // without the _api. This code is meant to handle both situations
            const editLink = isUrlAbsolute(candidate[s[1]]) ? candidate[s[1]].split("_api")[1] : candidate[s[1]];
            parts.push(extractWebUrl(candidate[s[3]]), "_api", editLink);
        }
        else if (hOP(candidate, s[1])) {
            parts.push("_api", candidate[s[1]]);
        }
        else if (hOP(candidate, s[2])) {
            // we are dealing with verbose, which has an absolute uri
            parts.push(candidate.__metadata.uri);
        }
    }
    if (parts.length < 1) {
        Logger.write("No uri information found in ODataEntity parsing, chaining will fail for this object.", 2 /* Warning */);
        return "";
    }
    return combine(...parts);
}
class SPODataEntityParserImpl extends ODataParser {
    constructor(factory) {
        super();
        this.factory = factory;
        this.hydrate = (d) => {
            const o = this.factory(odataUrlFrom(d), null);
            return assign(o, d);
        };
    }
    parse(r) {
        return super.parse(r).then((d) => {
            const o = this.factory(odataUrlFrom(d), null);
            return assign(o, d);
        });
    }
}
class SPODataEntityArrayParserImpl extends ODataParser {
    constructor(factory) {
        super();
        this.factory = factory;
        this.hydrate = (d) => {
            return d.map(v => {
                const o = this.factory(odataUrlFrom(v), null);
                return assign(o, v);
            });
        };
    }
    parse(r) {
        return super.parse(r).then((d) => {
            return d.map(v => {
                const o = this.factory(odataUrlFrom(v), null);
                return assign(o, v);
            });
        });
    }
}
export function spODataEntity(factory) {
    return new SPODataEntityParserImpl(factory);
}
export function spODataEntityArray(factory) {
    return new SPODataEntityArrayParserImpl(factory);
}
//# sourceMappingURL=odata.js.map