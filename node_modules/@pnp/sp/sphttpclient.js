import { __awaiter } from "tslib";
import { assign, mergeHeaders, getCtxCallback, combine, dateAdd, DefaultRuntime, Runtime, } from "@pnp/common";
import { extractWebUrl } from "./utils/extractweburl.js";
import { tag } from "./telemetry.js";
import { ODataParser } from "@pnp/odata";
export class SPHttpClient {
    constructor(...args) {
        // constructor(...args: [runtime: Runtime] | [impl: IHttpClientImpl, runtime?: Runtime]) {
        var _a;
        if (args[0] instanceof Runtime) {
            this._runtime = args[0];
        }
        else {
            this._runtime = args.length > 1 && args[1] instanceof Runtime ? args[1] : DefaultRuntime;
            this._impl = args[0];
        }
        this._impl = ((_a = this._runtime.get("sp")) === null || _a === void 0 ? void 0 : _a.fetchClientFactory()) || null;
        if (this._impl === null) {
            throw Error("Could not generate fetchClientFactory in SPHttpClient.");
        }
        this._digestCache = getDigestFactory(this);
    }
    fetch(url, options = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let opts = assign(options, { cache: "no-cache", credentials: "same-origin" }, true);
            const headers = new Headers();
            // first we add the global headers so they can be overwritten by any passed in locally to this call
            mergeHeaders(headers, (_a = this._runtime.get("sp")) === null || _a === void 0 ? void 0 : _a.headers);
            // second we add the local options so we can overwrite the globals
            mergeHeaders(headers, options.headers);
            // lastly we apply any default headers we need that may not exist
            if (!headers.has("Accept")) {
                headers.append("Accept", "application/json");
            }
            if (!headers.has("Content-Type")) {
                headers.append("Content-Type", "application/json;odata=verbose;charset=utf-8");
            }
            if (!headers.has("X-ClientService-ClientTag")) {
                const methodName = tag.getClientTag(headers);
                let clientTag = `PnPCoreJS:2.1.1:${methodName}`;
                if (clientTag.length > 32) {
                    clientTag = clientTag.substr(0, 32);
                }
                headers.append("X-ClientService-ClientTag", clientTag);
            }
            opts = assign(opts, { headers: headers });
            // if we have either a request digest or an authorization header we don't need a digest
            if (opts.method && opts.method.toUpperCase() !== "GET" && !headers.has("X-RequestDigest") && !headers.has("Authorization")) {
                const digest = yield this._digestCache(extractWebUrl(url));
                headers.append("X-RequestDigest", digest);
            }
            return this.fetchRaw(url, opts);
        });
    }
    fetchRaw(url, options = {}) {
        // here we need to normalize the headers
        const rawHeaders = new Headers();
        mergeHeaders(rawHeaders, options.headers);
        options = assign(options, { headers: rawHeaders });
        const retry = (ctx) => {
            // handles setting the proper timeout for a retry
            const setRetry = (response) => {
                let delay;
                if (response.headers.has("Retry-After")) {
                    // if we have gotten a header, use that value as the delay value in seconds
                    delay = parseInt(response.headers.get("Retry-After"), 10) * 1000;
                }
                else {
                    // grab our current delay
                    delay = ctx.delay;
                    // Increment our counters.
                    ctx.delay *= 2;
                }
                ctx.attempts++;
                // If we have exceeded the retry count, reject.
                if (ctx.retryCount <= ctx.attempts) {
                    ctx.reject(Error(`Retry count exceeded (${ctx.retryCount}) for request. Response status: [${response.status}] ${response.statusText}`));
                }
                else {
                    // Set our retry timeout for {delay} milliseconds.
                    setTimeout(getCtxCallback(this, retry, ctx), delay);
                }
            };
            // send the actual request
            this._impl.fetch(url, options).then((response) => {
                if (response.status === 429) {
                    // we have been throttled
                    setRetry(response);
                }
                else {
                    ctx.resolve(response);
                }
            }).catch((response) => {
                if (response.status === 503 || response.status === 504) {
                    // http status code 503 or 504, we can retry this
                    setRetry(response);
                }
                else {
                    ctx.reject(response);
                }
            });
        };
        return new Promise((resolve, reject) => {
            retry.call(this, {
                attempts: 0,
                delay: 100,
                reject: reject,
                resolve: resolve,
                retryCount: 7,
            });
        });
    }
    get(url, options = {}) {
        const opts = assign(options, { method: "GET" });
        return this.fetch(url, opts);
    }
    post(url, options = {}) {
        const opts = assign(options, { method: "POST" });
        return this.fetch(url, opts);
    }
    patch(url, options = {}) {
        const opts = assign(options, { method: "PATCH" });
        return this.fetch(url, opts);
    }
    delete(url, options = {}) {
        const opts = assign(options, { method: "DELETE" });
        return this.fetch(url, opts);
    }
}
// allows for the caching of digests across all HttpClient's which each have their own DigestCache wrapper.
const digests = new Map();
function getDigestFactory(client) {
    return (webUrl) => __awaiter(this, void 0, void 0, function* () {
        var _a, _b;
        const cachedDigest = digests.get(webUrl);
        if (cachedDigest !== undefined) {
            const now = new Date();
            if (now < cachedDigest.expiration) {
                return cachedDigest.value;
            }
        }
        const url = combine(webUrl, "/_api/contextinfo");
        const headers = {
            "Accept": "application/json;odata=verbose",
            "Content-Type": "application/json;odata=verbose;charset=utf-8",
        };
        const resp = yield client.fetchRaw(url, {
            cache: "no-cache",
            credentials: "same-origin",
            headers: assign(headers, (_b = (_a = client._runtime.get("sp")) === null || _a === void 0 ? void 0 : _a.sp) === null || _b === void 0 ? void 0 : _b.headers, true),
            method: "POST",
        });
        const parsed = yield (new ODataParser()).parse(resp).then(r => r.GetContextWebInformation);
        const newCachedDigest = {
            expiration: dateAdd(new Date(), "second", parsed.FormDigestTimeoutSeconds),
            value: parsed.FormDigestValue,
        };
        digests.set(webUrl, newCachedDigest);
        return newCachedDigest.value;
    });
}
//# sourceMappingURL=sphttpclient.js.map