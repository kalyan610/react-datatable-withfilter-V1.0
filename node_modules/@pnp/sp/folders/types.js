import { __awaiter, __decorate } from "tslib";
import { assign, isUrlAbsolute, combine } from "@pnp/common";
import { SharePointQueryable, SharePointQueryableCollection, SharePointQueryableInstance, _SharePointQueryableInstance, _SharePointQueryableCollection, spInvokableFactory, deleteableWithETag, } from "../sharepointqueryable.js";
import { odataUrlFrom } from "../odata.js";
import { Item } from "../items/types.js";
import { body } from "@pnp/odata";
import { defaultPath } from "../decorators.js";
import { spPost } from "../operations.js";
import { escapeQueryStrValue } from "../utils/escapeQueryStrValue.js";
import { extractWebUrl } from "../utils/extractweburl.js";
import { tag } from "../telemetry.js";
import { toResourcePath } from "../utils/toResourcePath.js";
let _Folders = class _Folders extends _SharePointQueryableCollection {
    /**
     * Gets a folder by it's name
     *
     * @param name Folder's name
     */
    getByName(name) {
        return tag.configure(Folder(this).concat(`('${escapeQueryStrValue(name)}')`), "fs.getByName");
    }
    /**
     * Adds a new folder at the specified URL
     *
     * @param url
     */
    add(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield spPost(this.clone(Folders, `add('${escapeQueryStrValue(url)}')`));
            return {
                data,
                folder: this.getByName(url),
            };
        });
    }
    /**
     * Adds a new folder by path and should be prefered over add
     *
     * @param serverRelativeUrl The server relative url of the new folder to create
     * @param overwrite True to overwrite an existing folder, default false
     */
    addUsingPath(serverRelativeUrl, overwrite = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield spPost(this.clone(Folders, `addUsingPath(DecodedUrl='${escapeQueryStrValue(serverRelativeUrl)}',overwrite=${overwrite})`));
            return {
                data,
                folder: Folder(extractWebUrl(this.toUrl()), `_api/web/getFolderByServerRelativePath(decodedUrl='${escapeQueryStrValue(serverRelativeUrl)}')`),
            };
        });
    }
};
__decorate([
    tag("fs.add")
], _Folders.prototype, "add", null);
__decorate([
    tag("fs.addUsingPath")
], _Folders.prototype, "addUsingPath", null);
_Folders = __decorate([
    defaultPath("folders")
], _Folders);
export { _Folders };
export const Folders = spInvokableFactory(_Folders);
export class _Folder extends _SharePointQueryableInstance {
    constructor() {
        super(...arguments);
        this.delete = deleteableWithETag("f");
        /**
         * Updates folder's properties
         * @param props Folder's properties to update
         */
        this.update = this._update("SP.Folder", data => ({ data, folder: this }));
    }
    /**
     * Specifies the sequence in which content types are displayed.
     *
     */
    get contentTypeOrder() {
        return tag.configure(SharePointQueryableCollection(this, "contentTypeOrder"), "f.contentTypeOrder");
    }
    /**
     * Gets this folder's sub folders
     *
     */
    get folders() {
        return Folders(this);
    }
    /**
     * Gets this folder's list item field values
     *
     */
    get listItemAllFields() {
        return tag.configure(SharePointQueryableInstance(this, "listItemAllFields"), "f.listItemAllFields");
    }
    /**
     * Gets the parent folder, if available
     *
     */
    get parentFolder() {
        return tag.configure(Folder(this, "parentFolder"), "f.parentFolder");
    }
    /**
     * Gets this folder's properties
     *
     */
    get properties() {
        return tag.configure(SharePointQueryableInstance(this, "properties"), "f.properties");
    }
    /**
     * Gets this folder's server relative url
     *
     */
    get serverRelativeUrl() {
        return tag.configure(SharePointQueryable(this, "serverRelativeUrl"), "f.serverRelativeUrl");
    }
    /**
     * Gets a value that specifies the content type order.
     *
     */
    get uniqueContentTypeOrder() {
        return tag.configure(SharePointQueryableCollection(this, "uniqueContentTypeOrder"), "f.uniqueContentTypeOrder");
    }
    /**
     * Moves the folder to the Recycle Bin and returns the identifier of the new Recycle Bin item.
     */
    recycle() {
        return spPost(this.clone(Folder, "recycle"));
    }
    /**
     * Gets the associated list item for this folder, loading the default properties
     */
    getItem(...selects) {
        return __awaiter(this, void 0, void 0, function* () {
            const q = yield this.listItemAllFields.select(...selects)();
            return assign(Item(odataUrlFrom(q)), q);
        });
    }
    /**
     * Moves a folder to destination path
     *
     * @param destUrl Absolute or relative URL of the destination path
     */
    moveTo(destUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const urlInfo = yield this.getParentInfos();
            const uri = new URL(urlInfo.ParentWeb.Url);
            yield spPost(Folder(uri.origin, "/_api/SP.MoveCopyUtil.MoveFolder()"), body({
                destUrl: isUrlAbsolute(destUrl) ? destUrl : combine(uri.origin, destUrl),
                srcUrl: combine(uri.origin, urlInfo.Folder.ServerRelativeUrl),
            }));
        });
    }
    /**
     * Moves a folder by path to destination path
     * Also works with different site collections.
     *
     * @param destUrl Absolute or relative URL of the destination path
     * @param keepBoth Keep both if folder with the same name in the same location already exists?
     */
    moveByPath(destUrl, KeepBoth = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const urlInfo = yield this.getParentInfos();
            const uri = new URL(urlInfo.ParentWeb.Url);
            yield spPost(Folder(uri.origin, "/_api/SP.MoveCopyUtil.MoveFolderByPath()"), body({
                destPath: toResourcePath(isUrlAbsolute(destUrl) ? destUrl : combine(uri.origin, destUrl)),
                options: {
                    KeepBoth,
                    ResetAuthorAndCreatedOnCopy: true,
                    ShouldBypassSharedLocks: true,
                    __metadata: {
                        type: "SP.MoveCopyOptions",
                    },
                },
                srcPath: toResourcePath(combine(uri.origin, urlInfo.Folder.ServerRelativeUrl)),
            }));
        });
    }
    /**
     * Copies a folder to destination path
     *
     * @param destUrl Absolute or relative URL of the destination path
     */
    copyTo(destUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            const urlInfo = yield this.getParentInfos();
            const uri = new URL(urlInfo.ParentWeb.Url);
            yield spPost(Folder(uri.origin, "/_api/SP.MoveCopyUtil.CopyFolder()"), body({
                destUrl: isUrlAbsolute(destUrl) ? destUrl : combine(uri.origin, destUrl),
                srcUrl: combine(uri.origin, urlInfo.Folder.ServerRelativeUrl),
            }));
        });
    }
    /**
     * Copies a folder by path to destination path
     * Also works with different site collections.
     *
     * @param destUrl Absolute or relative URL of the destination path
     * @param keepBoth Keep both if folder with the same name in the same location already exists?
     */
    copyByPath(destUrl, KeepBoth = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const urlInfo = yield this.getParentInfos();
            const uri = new URL(urlInfo.ParentWeb.Url);
            yield spPost(Folder(uri.origin, "/_api/SP.MoveCopyUtil.CopyFolderByPath()"), body({
                destPath: toResourcePath(isUrlAbsolute(destUrl) ? destUrl : combine(uri.origin, destUrl)),
                options: {
                    KeepBoth: KeepBoth,
                    ResetAuthorAndCreatedOnCopy: true,
                    ShouldBypassSharedLocks: true,
                    __metadata: {
                        type: "SP.MoveCopyOptions",
                    },
                },
                srcPath: toResourcePath(combine(uri.origin, urlInfo.Folder.ServerRelativeUrl)),
            }));
        });
    }
    /**
     * Deletes the folder object with options.
     *
     * @param parameters Specifies the options to use when deleting a folder.
     */
    deleteWithParams(parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            return spPost(this.clone(Folder, "DeleteWithParameters"), body({ parameters }));
        });
    }
    /**
     * Create the subfolder inside the current folder, as specified by the leafPath
     *
     * @param leafPath leafName of the new folder
     */
    addSubFolderUsingPath(leafPath) {
        return __awaiter(this, void 0, void 0, function* () {
            yield spPost(this.clone(Folder, "AddSubFolderUsingPath"), body({ leafPath: toResourcePath(leafPath) }));
            return this.folders.getByName(leafPath);
        });
    }
    /**
     * Gets the parent information for this folder's list and web
     */
    getParentInfos() {
        return __awaiter(this, void 0, void 0, function* () {
            const urlInfo = yield this.select("ServerRelativeUrl", "ListItemAllFields/ParentList/Id", "ListItemAllFields/ParentList/RootFolder/UniqueId", "ListItemAllFields/ParentList/RootFolder/ServerRelativeUrl", "ListItemAllFields/ParentList/RootFolder/ServerRelativePath", "ListItemAllFields/ParentList/ParentWeb/Id", "ListItemAllFields/ParentList/ParentWeb/Url", "ListItemAllFields/ParentList/ParentWeb/ServerRelativeUrl", "ListItemAllFields/ParentList/ParentWeb/ServerRelativePath").expand("ListItemAllFields/ParentList", "ListItemAllFields/ParentList/RootFolder", "ListItemAllFields/ParentList/ParentWeb")();
            return {
                Folder: {
                    ServerRelativeUrl: urlInfo.ServerRelativeUrl,
                },
                ParentList: {
                    Id: urlInfo.ListItemAllFields.ParentList.Id,
                    RootFolderServerRelativePath: urlInfo.ListItemAllFields.ParentList.RootFolder.ServerRelativePath,
                    RootFolderServerRelativeUrl: urlInfo.ListItemAllFields.ParentList.RootFolder.ServerRelativeUrl,
                    RootFolderUniqueId: urlInfo.ListItemAllFields.ParentList.RootFolder.UniqueId,
                },
                ParentWeb: {
                    Id: urlInfo.ListItemAllFields.ParentList.ParentWeb.Id,
                    ServerRelativePath: urlInfo.ListItemAllFields.ParentList.ParentWeb.ServerRelativePath,
                    ServerRelativeUrl: urlInfo.ListItemAllFields.ParentList.ParentWeb.ServerRelativeUrl,
                    Url: urlInfo.ListItemAllFields.ParentList.ParentWeb.Url,
                },
            };
        });
    }
    /**
     * Gets the shareable item associated with this folder
     */
    getShareable() {
        return __awaiter(this, void 0, void 0, function* () {
            // sharing only works on the item end point, not the file one - so we create a folder instance with the item url internally
            const d = yield this.clone(SharePointQueryableInstance, "listItemAllFields", false).select("odata.id")();
            let shareable = Item(odataUrlFrom(d));
            // we need to handle batching
            if (this.hasBatch) {
                shareable = shareable.inBatch(this.batch);
            }
            return shareable;
        });
    }
}
__decorate([
    tag("f.recycle")
], _Folder.prototype, "recycle", null);
__decorate([
    tag("f.getItem")
], _Folder.prototype, "getItem", null);
__decorate([
    tag("f.moveTo")
], _Folder.prototype, "moveTo", null);
__decorate([
    tag("f.moveByPath")
], _Folder.prototype, "moveByPath", null);
__decorate([
    tag("f.copyTo")
], _Folder.prototype, "copyTo", null);
__decorate([
    tag("f.copyByPath")
], _Folder.prototype, "copyByPath", null);
__decorate([
    tag("f.del-params")
], _Folder.prototype, "deleteWithParams", null);
__decorate([
    tag("f.getShareable")
], _Folder.prototype, "getShareable", null);
export const Folder = spInvokableFactory(_Folder);
//# sourceMappingURL=types.js.map